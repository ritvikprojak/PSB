Dim CurrentObj 
sub set_novCDCO(novCDCOObj) 
	set CurrentObj = Nothing 
	set CurrentObj = novCDCOObj 
end sub 
sub set_CDCOnothing() 
	set CurrentObj = Nothing 
end sub 
'namespace ()
                
'*****************************************************************************
' RRunner.rrx Script File
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2020 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'*****************************************************************************

'(Declarations)

On Error Resume Next 

Dim gbRRX
gbRRX = True
Dim PicCharAr(10)
Dim FileMgr
Dim ImageCtrl
Dim oConn
Dim CCOCreator
Dim gbDebug
Dim gbInteractive
Dim gbInter
Dim g_Atmr
Dim g_Ftmr
Dim g_Rtmr
Dim g_ATottmr
Dim g_FTottmr
Dim g_RTottmr
Dim g_ABatchtmr
Dim g_FBatchtmr
Dim g_RBatchtmr
Dim nDefID
Dim conn
Dim oCurPage
Dim bAbort
Dim sVarName
Dim CCO
Dim bFail
Dim bOverride
Dim nReturnStatus
Dim arRules
Dim nCurRule
Dim arActions
Dim nCurAction
Dim nDefaultRtn
Dim nRectIndex
Dim dictExists
Dim dictTmp
Dim dictPreserve
Dim g_nRuleType
Dim g_InitObj
Dim g_bRulestats
Dim nTaskStatus
Dim g_LogInset
Dim bEnableUI
Dim bProcessChildren
Dim g_bAbortOnError
Dim g_aggrStat
Dim gbLoadedCCO
Dim g_sFPDBDSN
gbLoadedCCO=""
strBaseImageName=""
g_sFPDBDSN=""

Dim nFail
Dim nPass
Dim nOver
Dim nAbort
Dim nPreserve

nFail = 1
nPass = 0
nOver = 3
nAbort = -1

nPreserve = True
g_bRuleStats = False
bEnableUI = True
g_LogInset = 0
bAbort = False
g_bAbortOnError = False

'TaskStatus List
Const RetAbort 	= 0
Const RetFinished = 2
Const RetHold 	= 4
Const RetPending 	= 8

'DCO Constants
Const DCO_BATCH = 0
Const DCO_DOCUMENT = 1
Const DCO_PAGE = 2
Const DCO_FIELD = 3
Const DCO_CHARACTER = 4

Dim dictInitGlobal
Set dictInitGlobal = CreateObject("Scripting.dictionary")

Const nRtn_Over = 1
Const nRtn_Fail = 2

bOverride = True
nTaskStatus = RetFinished 

'ADODB Constants
Const adOpenForwardOnly = 0
Const adOpenKeyset = 1
Const adOpenDynamic = 2
Const adOpenStatic = 3

Const adLockReadOnly = 1
Const adLockPessimistic = 2
Const adLockOptimistic = 3

Const adUseClient = 3
Const adUseServer = 2

'Statistics Variables
Dim g_RRnDocDict
Dim g_RRnPagDict
Set g_RRnDocDict = CreateObject("Scripting.dictionary")
Set g_RRnPagDict = CreateObject("Scripting.dictionary")

'Elapsed Time counter
Dim g_eTime
g_eTime=0

'QA DATA
Dim sStateStack
sStateStack=""
Dim rr_xDom
Set rr_xDom = CreateObject("MSXML2.DOMDocument")
rr_xDom.Async=False  

'Global DCO Object Dictionary
Dim dictDCOGlobal
Set dictDCOGlobal = CreateObject("Scripting.dictionary")

'Create DCSmart Object
Dim g_DCSmart
Set g_DCSmart = CreateObject("dcSmart.SmartNav")

If IsAlive(g_DCSmart) then 
	WriteLog("Smartparameter Object created")
	g_DCSmart.DatacapRRDCO=DCO
	g_DCSmart.DatacapRRLog=DCLogX
	g_DCSmart.SetRRCurrentDCO(CurrentObj)
	g_DCSmart.DatacapRRBatchPilot=Pilot
	g_DCSmart.DatacapRRState=RRState
End if

Dim DCGlobalStrings
Set DCGlobalStrings = CreateObject("Datacap.Global.Strings")
If IsAlive(DCGlobalStrings) then WriteLog("Datacap Global Strings Object created")

Dim DCGlobalDates
Set DCGlobalDates = CreateObject("Datacap.Global.Dates")
If IsAlive(DCGlobalDates) then WriteLog("Datacap Global Dates Object created")

Dim DCGlobalCurrency
Set DCGlobalCurrency = CreateObject("Datacap.Global.Currency")
If IsAlive(DCGlobalCurrency) then WriteLog("Datacap Global Currency Object created")

Dim DCGlobalLocale
Set DCGlobalLocale = CreateObject("Datacap.Global.Locale")
If IsAlive(DCGlobalLocale) then WriteLog("Datacap Global Locale Object created")

Dim DCGlobalBidi
Set DCGlobalBidi = CreateObject("Datacap.Global.Bidi")
If IsAlive(DCGlobalBidi) then WriteLog("Datacap Global Bidi Object created")

Dim RRLogic
Set RRLogic = CreateObject("Datacap.Libraries.RuleRunnerLogic.Actions")
If IsAlive(RRLogic) then    
   WriteLog("RRLogic Object created")
End If

Dim sOriginalLocaleID
sOriginalLocaleID = ""

'Note: 9.1.8.156 populated via RRX.cs
WriteLog("rrunner: loading file v. 9.1.8.156")
Call UpdateLocale()

'INIT RRS OBJECTS - RRX ONLY

Sub ErrorHandler(strmsg)
   'Nothing to do here
End sub

Sub InitObjects()

  On Error Resume Next

	Set FileMgr = CreateObject("Scripting.FileSystemObject")
  If IsAlive(FileMgr) then WriteLog("Global FileMgr Object created")
  
	Set ImageCtrl = CreateObject("DCIMAGE.DcimageCtrl.1")
  If IsAlive(ImageCtrl) then WriteLog("Global ImageCtrl Object created")
  
	Set oConn = CreateObject("ADODB.Connection")
	If IsAlive(oConn) then WriteLog("Global oConn Object created")
  
	Set CCOCreator=CreateObject("CCO._CCOCreator")
	If IsAlive(CCOCreator) then WriteLog("Global CCOCreator Object created")
  CCOCreator.MaxWaitTime = 5000	' wait up to 5 seconds for CCO to exist
	
	gbDebug = RRState.DebugMode
	gbInteractive = RRState.Interactive
	gbInter = RRState.Interactive

  Set CCO = Nothing
  Set CCO = CreateObject("CCO._CCOCollection")
  If IsAlive(CCO) then WriteLog("Global CCO Object created")

  'Log the batch xml
  Call Writelog("Pilot XML:" & vbcrlf & Pilot.ExportXML() & vbcrlf)
End sub

Call InitObjects()
  
Sub InitPage()
  'Find current parent page and load CCO if it has a cco file
  Dim oPage
  On Error Resume Next
  
  If IsAlive(CurrentObj) then ' ---- Added for Quattro compatibility to fix error described in SPR 23678 (update "7.6.41")
     WriteLog("InitPage")
     Set oPage = CurrentObj
     
     While oPage.ObjectType<>2 and oPage.ObjectType>0
        Set oPage = oPage.Parent    
     Wend
     
     If oPage.ObjectType=0 then Exit Sub
     
     Call LoadCCO(oPage)
     
     Set oCurPage = Nothing
     Set oCurPage = oPage
  Else
     Call Writelog("CurrentObj is Nothing")     
  End if
  
End Sub
 
Sub LoadCCO(oPage)
  Dim sVar
  Dim strBaseImageName
  Dim bFound

  On Error Resume Next

  bFound=False
  sVar="DATAFILE"
        
  If oPage.FindVariable(sVar)<0 Then sVar="IMAGEFILE"
  
  If oPage.FindVariable(sVar)>=0 Then  				
  
     'Initially it was hardcoded to 3 considering image extension to be always 3 characters. 
     'Modified it with realExt variable which will work for any number of characters in extension.
     Dim aPath
     Dim realExt
     aPath =Split(oPage.ImageName,".")
     Dim l
     l=UBound(aPath)
     'Get the last item of an array which will be the real extenstion of an image.
     realExt = aPath(l)

     strBaseImageName = Left(oPage.Variable(sVar), Len(oPage.Variable(sVar)) - Len(realExt)) & "cco"  ' Remove the extension to change it to .CCO
  
     If ("ForceCCOReload" = gbLoadedCCO) Then
        gbLoadedCCO = ""
        RRState.OnActionSuccess="Call OnActionSuccess()"  ' Reset to the standard call. Removes the call to gbLoadedCCO = "ForceCCOReload"  Refer to SharedRecognitionTools for more information
        WriteLog("VBSCCOReload")
     End If
        
     'Check if CCO matches Loaded CCO
     If ucase(gbLoadedCCO)=ucase(strBaseImageName) and strBaseImageName<>"" then Exit Sub

     'If Not IsAlive(CCOCreator) then 
        'Writelog ("RRunner LoadCCO: CCOCreator is not alive")
     'End If
    
     Call Writelog("RRunner LoadCCO attempt to load CCO file: '" & strBaseImageName & "'")
     'If FileMgr.FileExists(strBaseImageName) Then
        'Writelog ("RRunner LoadCCO: strBaseImageName exists.")
     'End If

     If FileMgr.FileExists(strBaseImageName) Then
        If Not IsAlive(CCOCreator) then Set CCOCreator=CreateObject("CCO._CCOCreator")

        If IsAlive(DCLogX) Then
           'WriteLog("Set DCLogX")
           CCOCreator.LogX = DCLogX ' requires debug version of CCOCreator
           If Err.Number <> 0 then WriteLog("Err " & Err.Description)

           If oPage.FindVariable("CCOFILE") >= 0 Then
              'WriteLog("Set MaxWaitTime")
              CCOCreator.MaxWaitTime = 5000	' wait up to 5 seconds for CCO to exist
              If Err.Number <> 0 then WriteLog("Err " & Err.Description)
           End If
        End If
        
        'Writelog ("RRunner LoadCCO: Going to set CCO to Nothing") 
  
        Set CCO=Nothing
                
        CCOCreator.MaxWaitTime = 5000	' wait up to 5 seconds for CCO to exist
        'WriteLog("rrunner loading CCO")
        Set CCO=CCOCreator.Load(strBaseImageName)
        If IsAlive(CCO) Then 'Added for Quattro compatibility SPR# 25101 update 7.6.46
           'Call Writelog("Loaded CCO 1:'" & strBaseImageName & "'" & ", count=" & CCO.Count)
           Writelog ("RRunner LoadCCO: Loaded CCO.")
           if (CCO.Count < 1) then WriteLog("Loaded empty CCO")
           bFound=True
           gbLoadedCCO=strBaseImageName
           Call CCO.SetCurrentPosition(1,1)
        Else
           Writelog ("Error: CCO object Is Nothing")
        End if
    End if
    
    If TrapError("Getting Data File name for " & oPage.Id)=False Then
    End If
       
  End if

   If bFound=False then  
      'create empty cco for pages with no images or data 
      If IsAlive(CCOCreator) then 
         'Writelog ("RRunner LoadCCO: Checking if CCO object is IsAlive.")
         If IsAlive(CCO) then 
            'Call Writelog("RRunner LoadCCO: Old CCO Count is'" & CCO.Count & "'")
            'consider the max CCO count at root level be less than 50000
            If (CCO.Count > 0 And CCO.Count < 50000) then 
               'Writelog ("RRunner LoadCCO: Setting CCO object to Nothing.")
               Set CCO=Nothing

               'block added to try to handle the crash exit during setting CCO to Nothing
               If Err.Number <> 0 then WriteLog("Err " & Err.Description)
            End If   
            
         End If
      End If   
	  
	    'Writelog ("RRunner LoadCCO: CreateObject CCO._CCOCollection")
	    Set CCO=CreateObject("CCO._CCOCollection")
   End If


End Sub

'------ Initialize Timers on load ------
g_ATottmr=cdbl(0)
g_FTottmr=cdbl(0)
g_RTottmr=cdbl(0)
g_ABatchtmr=cdbl(0)
g_FBatchtmr=cdbl(0)
g_RBatchtmr=cdbl(0)

g_Atmr=cdbl(Timer)
g_Ftmr=cdbl(Timer)
g_Rtmr=cdbl(Timer)

Call InitPage()      

Sub InitDStudio()
  'Initialize the Pilot.ProjectPath() property for use in DStudio.
  'Must point to the DCO setup folder with Paths.ini as the target filename.
  Dim sPath
  Dim oDCOSetup
  
  On Error Resume Next
  
  If IsAlive(Pilot) Then
    If Pilot.ProjectPath="" then
      Set oDCOSetup = DCO.SetupObject()
      sPath=FileMgr.GetParentFolderName(oDCOSetup.Path)
      sProjPath=FileMgr.BuildPath(sPath,"Paths.ini")
      Pilot.ProjectPath=sProjPath
      Set oDCOSetup = Nothing
    End if
  End if
  
End Sub

Call InitDStudio()

'------ Initialize On Load -------
RRState.OnProcessStart="Call OnProcessStart()"
RRState.OnActionStart="Call OnActionStart()"
RRState.OnActionFailure="Call OnActionFailure()"
RRState.OnActionSuccess="Call OnActionSuccess()"
RRState.OnFunctionStart="g_Ftmr=cdbl(Timer)"
RRState.OnFunctionFailure="Call OnFunctionEnd()"
RRState.OnFunctionSuccess="Call OnFunctionEnd()"
RRState.OnRuleStart="Call OnRuleStart()"
RRState.OnRuleFailure="Call StatCounter():Call OnRuleEnd():Call RRLogicOnRuleEnd()"
RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd():Call RRLogicOnRuleEnd()"
RRState.OnRuleSetStart="Call OnRuleSetStart()"
RRState.OnRuleSetEnd="Call OnRuleSetEnd()"
RRState.OnProcessEnd="Quit()"

 'Reset RRS Data Elements
  RRState.Pop("nTaskStatus")
  RRState.Data("ActionAbortLog")="False"
  RRState.Data("bOverride")="True"
  RRState.Data("bAbort")="False"
  RRState.Data("stats_nDocs")=cstr(0)
  RRState.Data("stats_nPages")=cstr(0)
  RRState.LogicResult=1
  

Sub OnProcessStart() 
  RRState.OnActionStart="Call OnActionStart()"
  RRState.OnActionFailure="Call OnActionFailure()"
  RRState.OnActionSuccess="Call OnActionSuccess()"
  RRState.OnFunctionStart="g_Ftmr=cdbl(Timer)"
  RRState.OnFunctionFailure="Call OnFunctionEnd()"
  RRState.OnFunctionSuccess="Call OnFunctionEnd()"
  RRState.OnRuleStart="Call OnRuleStart()"
  RRState.OnRuleFailure="Call StatCounter():Call OnRuleEnd():Call RRLogicOnRuleEnd()"
  RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd():Call RRLogicOnRuleEnd()"
  RRState.OnRuleSetStart="Call OnRuleSetStart()"
  RRState.OnRuleSetEnd="Call OnRuleSetEnd()"
  RRState.OnProcessEnd="Quit()"
  
 'Reset RRS Data Elements
  RRState.Pop("nTaskStatus")
  RRState.Data("ActionAbortLog")="False"
  RRState.Data("bOverride")="True"
  RRState.Data("bAbort")="False"
  RRState.Data("stats_nDocs")=cstr(0)
  RRState.Data("stats_nPages")=cstr(0)
  RRState.LogicResult=1

End Sub

Sub OnActionStart() 
  On Error Resume Next

  'Enable Dynamic Locale
  Call UpdateLocale()
  'Initialize Action Timer
  g_Atmr=cdbl(Timer)
  
End Sub

Sub OnActionFailure() 
  On Error Resume Next
  
  'TEST
  Call QAStateData("False")
    
  Call OnActionEnd()
  
  
  
End Sub

Sub OnActionSuccess() 
  On Error Resume Next
  
  'TEST
  Call QAStateData("True")
    
  Call OnActionEnd()
   
  
End Sub

Sub OnActionEnd() 
  
    Dim sTime
    Dim bBypassAbort 
    
    sTime=rr_eTimer(g_Atmr)
    
    g_Atmr=cdbl(0)
    g_ATottmr=g_ATottmr+sTime
       
    'Check for unhandled action error
    Call ErrorHandler("RRunner OnActionEnd() has caught an error from the previous action.")
    
    If (bAbort=True or RRState.Data("bAbort")="True") and  RRState.LogicResult<>-1 then
        If RRState.Data("ActionAbortLog")<>"True" then  
          Writelog("ATTENTION: This action has set the Task to Abort at the COMPLETION of the Ruleset. (bAbort=True)")
        Else
          Writelog("ATTENTION: An action run earlier in this ruleset has set the Task to Abort at the completion of the Ruleset. (bAbort=True)")
        End if
        'flag to only log the message once
        RRState.Data("ActionAbortLog")="True" 
    End if

    If cstr(nTaskStatus)=cstr(0) or cstr(RRState.Data("nTaskStatus"))=cstr(RetAbort) then
        RRState.LogicResult=-1
    End if

    Writelog("Action esec='" & FormatNumber(sTime,5,True) & "'")


End Sub

Sub OnFunctionEnd() 
    On Error Resume Next
  Dim sTime
        
  sTime = rr_eTimer(g_Ftmr)    
      
  g_Ftmr=cdbl(0)
  g_FTottmr=g_FTottmr+sTime
  If sTime<>cdbl(0) then Writelog("Function esec='" & FormatNumber(sTime,5,True) & "'")
    
  sStateStack=""
 
  
End Sub

Sub OnRuleStart() 
   'Initialize Rule Timer
   On Error Resume Next
   g_Rtmr=cdbl(Timer)
   Call InitPage()
   
   If IsAlive(g_DCSmart) then g_DCSmart.DatacapRRCurrentDCO = CurrentObj
   

End Sub

Sub OnRuleSetStart() 
Dim sValue

On Error Resume Next        
        
If IsAlive(g_DCSmart) then 
	g_DCSmart.DatacapRRState=RRState
	g_DCSmart.DatacapRRLog=DCLogX
	g_DCSmart.DatacapRRBatchPilot=Pilot
	g_DCSmart.DatacapRRDCO=DCO
	g_DCSmart.DatacapRRCurrentDCO = CurrentObj
End if

sValue = Pilot.ExportXML()

Call Writelog("OnRuleSetStart Pilot XML:" & vbcrlf & sValue & vbcrlf)


End Sub

Sub OnRuleSetEnd() 
If bAbort=True then nTaskStatus=retAbort

  'Sync Abort variables
  If RRState.Data("bAbort")="True" Then nTaskStatus=cstr(0) 
  If cstr(nTaskStatus)=cstr(0) then RRState.Data("bAbort")="True"
  If cstr(nTaskStatus)<>cstr(RetFinished) And cstr(RRState.Data("nTaskStatus"))<>cstr(RetFinished) then RRState.Data("nTaskStatus")=nTaskStatus

  'Setup Data to always have bOverrride value of True or False
  If RRState.Data("bOverride")<>"False" then RRState.Data("bOverride")="True"
  
  'Reset loaded CCO & ImageCtrl  
  gbLoadedCCO=""
  ImageCtrl.Filename="" 
 
  Call writelog("RuleSet finished with TaskStatus '" & cstr(nTaskStatus) & "'")

  'write RRState xml to log file
  Call Writelog("Total Ruleset Action   esec:'" & FormatNumber(g_ATottmr,5,True) & "'")
  Call Writelog("Total Ruleset Function esec:'" & FormatNumber(g_FTottmr,5,True) & "'")
  Call Writelog("Total Ruleset Rule     esec:'" & FormatNumber(g_RTottmr,5,True) & "'")
  
  g_ABatchtmr=g_ABatchtmr+cdbl(g_ATottmr)
  g_FBatchtmr=g_FBatchtmr+cdbl(g_FTottmr)
  g_RBatchtmr=g_RBatchtmr+cdbl(g_RTottmr)
  
  If g_ABatchtmr>g_ATottmr then Call Writelog("Total Profile Action   esec:'" & FormatNumber(g_ABatchtmr,5,True) & "'")
  If g_FBatchtmr>g_FTottmr then Call Writelog("Total Profile Function esec:'" & FormatNumber(g_FBatchtmr,5,True) & "'")
  If g_RBatchtmr>g_RTottmr then Call Writelog("Total Profile Rule     esec:'" & FormatNumber(g_RBatchtmr,5,True) & "'")
  
  g_ATottmr=cdbl(0)
  g_FTottmr=cdbl(0)
  g_RTottmr=cdbl(0)

  Dim sValue
  sValue = Pilot.ExportXML()

  Call Writelog("OnRuleSetEnd Pilot XML:" & vbcrlf & sValue & vbcrlf)

  If IsAlive(g_DCSmart) then g_DCSmart.DatacapRRCleanupTime = true


End Sub

Sub OnRuleEnd() 
  'Only used in RRX environment
   nDefaultRtn = nRtn_Over 

    Call RestoreLocale() ' Make sure we are back to the original locale

    Dim sTime
    sTime = rr_eTimer(g_Rtmr)   
       
    g_Rtmr=cdbl(0)
    g_RTottmr=g_RTottmr+sTime
        
    Call Writelog("rrRuleEnd OVERRIDEABLE:" & RRState.Data("bOverride"))
    If cstr(nTaskStatus)=cstr(0) then 
        RRState.LogicResult=-1
    End if
    If sTime<>cdbl(0) then Writelog("Rule esec='" & FormatNumber(sTime,5,True) & "'")
  
  If IsAlive(g_DCSmart) then g_DCSmart.DatacapRRCurrentDCO = Nothing
  

End Sub

Sub OnRuleFailure() 
   'Only used in RRX environment
    On Error Resume Next

    Call Writelog("OnRuleFailure...") 

        'Set CurrentObj status :'CurrentObj.Status=nFail
        Call rrFailNodes(CurrentObj)

        'Set Override/Non-Override flag
        If nDefaultRtn = nRtn_Fail Then
            RRState.Data("bOverride")="False"
            Call Writelog("rrRuleFailure OVERRIDEABLE:" & RRState.Data("bOverride"))
        End If

End Sub

Sub RRLogicSetDefaultRtnForOverride() 
  On Error Resume Next
  
  ' This is a wrapper to make a nice way to call RuleRunnerLogic 
  
  If Not IsAlive(RRLogic) then
      Set RRLogic = CreateObject("Datacap.Libraries.RuleRunnerLogic.Actions")
      WriteLog("RRLogicSetDefaultRtnForOverride Created RRLogic") ' This shouldn't really happen, it should already be created
  End If
  
  If IsAlive(RRLogic) then 
     RRLogic.DatacapRRLog = DCLogX
     RRLogic.DatacapRRCurrentDCO = CurrentObj
     RRLogic.DatacapRRBatchPilot = Pilot
     RRLogic.DatacapRRState = RRState
     RRLogic.SetDefaultRtnForOverride(1)
  Else
     WriteLog("Error: RRLogicSetDefaultRtnForOverride Could not load RRLogic")
  End If
   
  
End Sub

Sub RRLogicOnRuleFailure() 
  On Error Resume Next
  
  ' This is a wrapper to make a nice way to call RuleRunnerLogic 
  ' This handles the case where status preserve is OFF and the rule has ended with "FALSE"
  
  If Not IsAlive(RRLogic) then
      Set RRLogic = CreateObject("Datacap.Libraries.RuleRunnerLogic.Actions")
      WriteLog("RRLogicOnRuleFailure Created RRLogic")  ' This shouldn't really happen, it should already be created
  End If
  
  If IsAlive(RRLogic) then 
     'WriteLog("RRLogicOnRuleFailure called OnRuleFailure1") ' Just for debugging
     RRLogic.DatacapRRLog = DCLogX
     RRLogic.DatacapRRCurrentDCO = CurrentObj
     RRLogic.DatacapRRBatchPilot = Pilot
     RRLogic.DatacapRRState = RRState
     RRLogic.OnRuleFailure()
     'WriteLog("RRLogicOnRuleFailure called OnRuleFailure2") ' Just for debugging
  Else
     WriteLog("Error: RRLogicOnRuleFailure Could not load RRLogic")
  End If
   
  
End Sub

Sub RRLogicOnRuleEnd() 
  On Error Resume Next
  
  ' This is a wrapper to make a nice way to call RuleRunnerLogic 
  ' This is called everytime a rule completes
  
  If Not IsAlive(RRLogic) then
      Set RRLogic = CreateObject("Datacap.Libraries.RuleRunnerLogic.Actions")
      WriteLog("RRLogicOnRuleEnd Created RRLogic") ' This shouldn't really happen, it should already be created
  End If
  
  If IsAlive(RRLogic) then 
     'WriteLog("RRLogicOnRuleEnd called OnRuleFailure1") ' Just for debugging
     RRLogic.DatacapRRLog = DCLogX
     RRLogic.DatacapRRCurrentDCO = CurrentObj
     RRLogic.DatacapRRBatchPilot = Pilot
     RRLogic.DatacapRRState = RRState
     RRLogic.OnRuleEnd()
     'WriteLog("RRLogicOnRuleEnd called OnRuleFailure2") ' Just for debugging
  Else
     WriteLog("Error: RRLogicOnRuleEnd Could not load RRLogic")
  End If   
  
End Sub

Sub rrFailNodes(oNode) 
	Dim oParent
    
    On Error Resume Next
    
    'Only used in RRX environment
    If oNode is Nothing then Exit Sub
        
    'Set Node to Fail status
    If oNode.Status=nPass then 
      oNode.Status=nFail
      Call Writelog("rr Setting " & oNode.ID & " to Status '" & nFail & "'")
    Else
      Call Writelog("rr " & oNode.ID & " is not Status '" & nPass & "' ,will not set to Status '" & nFail & "'" )
    End if
    
    'Check for Parent Node to set status
    If oNode.Variable("victim")<>"yes" then
        If oNode.ObjectType<>DCO_BATCH then
      
            Set oParent=oNode.Parent()
            If oParent.Status<>nFail then 
                Call rrFailNodes(oParent)
            End if

            Set oParent=Nothing 
        End if
    Else
        Call Writelog(oNode.ID & " is Victim (Start Node)")
    End if
    

End Sub

Sub StatCounter() 
	 Dim ObjID  
   Dim ObjType
   Dim PagID
   Dim DocID
   Dim oParent
   Dim etime
   
   DocID = ""
   PagID = ""
   ObjID = Trim(CurrentObj.ID)
   If len(ObjID)=0 then Exit Sub
     
   Select Case CurrentObj.ObjectType
		Case 1
      'Document
      DocID=ObjID
      
		Case 2
      'Page
      PagID=ObjID

  End Select

  'Aggregate Statistic
  If g_aggrStat= True Then
    Set oParent=CurrentObj
    While (DocID="" or PagID="") AND oParent.ObjectType>0
      If oParent.ObjectType=2 then PagID=oParent.ID
      If oParent.ObjectType=1 then DocID=oParent.ID
      Set oParent=oParent.Parent
    Wend
  End if
  
  If PagID<>"" then
	  If Not g_RRnPagDict.Exists(PagID) then
      Call g_RRnPagDict.Add(PagID,1)
    End if
  End if
  
  If DocID<>"" then
    If Not g_RRnDocDict.Exists(DocID) Then
      Call g_RRnDocDict.Add(DocID,1)
    End if
  End if
  
  Writelog("DocCount " & g_RRnDocDict.Count & ",  PageCount " & g_RRnPagDict.Count)

  RRState.Data("stats_nDocs")=cstr(g_RRnDocDict.Count)
  RRState.Data("stats_nPages")=cstr(g_RRnPagDict.Count)
  Set oParent = Nothing
  

End Sub

Function DetermineLocale()
		
  ' Determine the locale that should be used.  First check hr_locale for the current object.  
  ' If not set, the current thread locale is returned
  ' The locale Name is returned, not the LCID
	
  On Error Resume Next

  Dim sLocale
  Dim sCurLocale
  
  'Find the locale variable, if it is set.  This value will override the current thread's locale.  Returns as 'Name'
  sLocale = CurrentObj.Variable("hr_locale")
  sLocale = trim(sLocale)
	  
  If len(sLocale)>0 and (Not sLocale="-1") then
     Writelog("hr_locale = " & sLocale)
     DetermineLocale = sLocale
     Exit Function
  End if
  
  sCurLocale = Trim(cStr(GetLocale()))  ' Returns as LCID
  DetermineLocale = DCGlobalLocale.Name(sCurLocale)
  WriteLog("Current Locale: '" & sCurLocale & " (" & DetermineLocale & ")' " & DCGlobalLocale.Description(sCurLocale))   
  Exit Function

End Function
		
Function RestoreLocale()
		
  ' Set the locale back to the original locale.
	
  On Error Resume Next

  if (sOriginalLocaleID = "") Then
    Exit Function
  End if

  'writelog("Restoring locale: " & sOriginalLocaleID)
  SetLocale(sOriginalLocaleID) ' Reset to the original locale.
  sOriginalLocaleID = ""

  Exit Function

End Function
		
Sub UpdateLocale() 
  On Error Resume Next
  
  Dim sLocaleName
  Dim sLocaleLCID
  Dim sCurLocale
  Dim sCurLocaleName
    
  sLocaleName = DetermineLocale    ' Returns Name  
  sLocaleLCID = Cstr(DCGlobalLocale.Lcid(sLocaleName))
  sCurLocale  = Cstr(GetLocale())  ' Returns LCID
  sCurLocaleName = DCGlobalLocale.Name(sCurLocale)
  
  if (sOriginalLocaleID = "") Then
    sOriginalLocaleID = sCurLocale
    'writelog("Saving original locale: " & sOriginalLocaleID)
  End if
  
  'Check current locale - exit if matched
  If sCurLocale = sLocaleLCID then
    ' WriteLog("rrunner: No change to RRS Locale '" & sCurLocale & " (" & sCurLocaleName & ")' " & DCGlobalLocale.Description(sCurLocale)) 
    Exit Sub
  End if
  
  If err.number<>0 then 
    Writelog("Error in UpdateLocale A. Err:" & Err.Number & " Description:" & Err.Description)
    Err.Clear
  End if
    
  'Update Script to new locale
  SetLocale(sLocaleLCID)
  WriteLog("rrunner: Changed RRS Locale from '" & sCurLocale  & " (" & sCurLocaleName & ")' " & "' to '" & sLocaleLCID & " (" & sLocaleName & ")' " & DCGlobalLocale.Description(sLocaleLCID)) 
  
  If err.number<>0 then 
    Writelog("Error in UpdateLocale B. Err:" & Err.Number & " Description:" & Err.Description)
    WriteLog("Error after attempting: rrunner: Existing RRS Locale '" & GetLocale() & "'. Setting Locale to '" & sLocaleLCID & "'.") 
    Err.Clear
  Else
    Writelog("Dynamic Locale: locale set to: '" & sLocaleName & "'")
  End if
  
  'Update action variables
  RRState.Data("hr_locale")=sLocaleName
  If err.number<>0 then 
    Writelog("Error in UpdateLocale C. Err:" & Err.Number & " Description:" & Err.Description)
    Err.Clear
  End if
  
  Pilot.TaskVar("hr_locale")=sLocaleName
  If err.number<>0 then 
    Writelog("Error in UpdateLocale D. Err:" & Err.Number & " Description:" & Err.Description)
    Err.Clear
  End if
   
  'WriteLog("Node Locale '" & GetLocale() & "'")

End Sub

Function QAStateData(result)
		
    Dim sFunct
    Dim sAction  
    Dim oNode
    Dim sNode
    
    On error resume next
      
    If cstr(RRState.Data("QA"))<>"1" then Exit Function 
  
	  sXML = RRState.XML

		If rr_xDom.LoadXML(sXML) Then
      
			'Get Function id
      sNode="//func"
			Set oNode=rr_xDom.SelectSingleNode(sNode)
		  If IsAlive(oNode) Then
				sFunct = oNode.GetAttribute("id")
        RRState.Data("LastFunctionName")=sFunct
			End If
		   					
      'Get Action id
      sNode="//func/a"
			Set oNode=rr_xDom.SelectSingleNode(sNode)
		  If IsAlive(oNode) Then
				sAction = oNode.GetAttribute("id")
        RRState.Data("LastActionName")=sAction
			End If                                                 
                                
      RRState.Data("LastActionResult")=result                        
                                
      If cstr(RRState.Data("QAS"))="1" then
        RRState.Data("QAStackLog")=RRState.Data("QAStackLog") & sAction & " --> " & result & vbcrlf
      End if
                                
		Else
			Writelog("QAStateData failed to load XML")
		End If

		Set oNode=Nothing
    
    writelog(RRState.xml)
    

End Function
		
Sub Log(sMessage) 
	bOut = Writelog(sMessage)

End Sub

Sub SetEnableUI(bOnOff) 
	bEnableUI = bOnOff

End Sub

Function dummy(returnWhat)
		
		dummy = returnWhat
		
End Function
		
Function CMyLng(sValue)
		
	CMylng=0
	If Trim(CStr(sValue))="" Then Exit Function
	If Not IsNumeric(sValue) Then Exit Function
	CMyLng = CLng(sValue)

End Function
		
Sub SetDefID(defaultID) 
	nDefID = defaultID

End Sub

Sub SetRR_ID(defaultID,oPage,oCCO) 
	nDefID = defaultID
	If IsObject(oPage) Then Set oCurPage=oPage
	If IsObject(oCCO) Then Set CCO=oCCO

End Sub

Function bPreserve()
		
	bPreserve = True
	If dictPreserve.Exists(g_nRuleType) Then
		bPreserve = CBool(dictPreserve(g_nRuleType))
		'Writelog("Preserve Status :" & CStr(bPreserve))
	End If	

End Function
		
Function GetTaskStatus()
		
	If bAbort = True Then nTaskStatus = RetAbort
	GetTaskStatus = nTaskStatus

End Function
		
Function GetAbort()
		
	GetAbort = False
	If bAbort = True Then GetAbort = True
	If nTaskStatus = RetAbort Then GetAbort= True

End Function
		
Function SetCurRule(nIndex)
		
	nCurRule = nIndex	

End Function
		
Function GetOverride()
		
	GetOverride=bOverride

End Function
		
Function GetReturnStatus()
		
	GetReturnStatus=nReturnStatus

End Function
		
Sub InitReturnStatus(Stat) 
	nReturnStatus = Stat
	bOverride=True

End Sub

Sub SetRuleStatistics(bEnabled) 
	g_bRuleStats = bEnabled

End Sub

Function GetDocCount()
		
	GetDocCount = g_RRnDocDict.Count 

End Function
		
Function GetPagCount()
		
	GetPagCount = g_RRnPagDict.Count

End Function
		
Function GetDataArray(sSQL)
		
	Dim arRes
	Dim rs
		
  On Error Resume Next  
    
  Const adOpenStatic = 3   
  Const adUseClient = 3
  Const adLockOptimistic = 3 
  Const adLockBatchOptimistic = 4 
    
		GetDataArray=arRes
	
		If InitFPDB=False Then Exit Function
	  	
    'Remove leading & trailing spaces
    sSQL=Trim(sSQL)
  
    If Instr(Ucase(conn.Provider),ucase("OraOLEDB"))>0 or Instr(Ucase(conn.Provider),Ucase("MSDAORA"))>0 Then
       'Remove "invalid" character semicolon if last character for Oracle DB's
       If instrrev(sSQL,";")=len(sSQL) Then
            sSQL=Trim(left(sSQL,len(sSQL)-1))
       End If
    End If	

		If InStr(sSQL, "SELECT")=1 Then
      Set rs = CreateObject("ADODB.RecordSet")
      rs.CursorLocation = adUseClient
      rs.Open sSQL, conn, adOpenStatic, adLockBatchOptimistic
      Set rs.ActiveConnection = Nothing
		Else
      conn.Execute(sSQL)
      Exit Function
		End If
		
		If DBErrTrap(conn, "GetDataArray1") Then
			If IsAlive(rs) then rs.Close()
			Set rs=Nothing
			Exit Function
		End If

		nCount=0

		If rs.EOF Then
			'Writelog(Space(4) & "No rows selected.")
			rs.Close()
			Set rs=Nothing
			Exit Function
		End If
	
		nCount=0
		
		rs.MoveFirst()

		While Not rs.EOF
			nCount=nCount+1
			rs.MoveNext()
		Wend

		rs.MoveFirst
		nCount=nCount-1
		nFields=rs.Fields.Count-1
		ReDim arRes(nCount, nFields)

		For i=0 To nCount
			For j=0 To nFields
				arRes(i,j)=rs.Fields(j).Value
				If DBErrTrap(conn,"GetDataArray2") Then
					rs.Close()
					Set rs=Nothing 
					Exit Function
				End If
			Next
			rs.MoveNext
		Next

		rs.Close()
		Set rs=Nothing
		
	GetDataArray=arRes
	

End Function
		
Function ModifySQLByDBType(oConnect,byval sSQL)
		
		
	On Error Resume Next
	Dim provider
	provider = UCase(oConnect.Provider)
	
    'Remove leading & trailing spaces
    sSQL=Trim(sSQL)
  
    If Instr(provider,"ORAOLEDB")>0 or Instr(provider,"MSDAORA")>0 Then
       'For Oracle DBs remove 'invalid' character (semicolon) if last character
       If instrrev(sSQL,";")=len(sSQL) Then
            sSQL=Trim(left(sSQL,len(sSQL)-1))
       End If
    End If
    
    ModifySQLByDBType = sSQL
	

End Function
		
Function Init(sDSN,bInteractive,bDeb,sVar)
		
	Dim sConnStr
	Init=False
	bInter=bInteractive
	bDebug=bDeb	
			
	Init=False
	
	On Error Resume Next
	
  If Not gbRRX then
	Call Writelog("rrunner.dcs " & rr_Version)
	End if
	
	nTaskStatus = RetFinished
	sVarName=sVar
	Set conn=CreateObject("ADODB.Connection")
	
  g_sFPDBDSN=sDSN
  
	If Not gbRRX then

    If InitFPDB=False Then
        Call Writelog("Init Connection Error:" & Err.Description)
        Writelog("No fingerprint/RulesDB connection Established. ABORTING!!")
        nTaskStatus = RetAbort
	      Err.Clear
      	Exit Function
	  End If
  
  End if 
	  
  If Not IsAlive(CCOCreator) then 
    Set CCOCreator=CreateObject("CCO._CCOCreator")
  End if
  
	If IsNull(CCOCreator) Or TrapError("CCO Creator Failure") Then
		nTaskStatus = RetAbort
		Writelog("CCOCreator Failure in INIT function")	
		Exit Function
	End If
	
  CCOCreator.MaxWaitTime = 5000	' wait up to 5 seconds for CCO to exist
  
  'Initialize Statistic Vars
	g_RRnDocDict.RemoveAll
	g_RRnPagDict.RemoveAll
  g_aggrStat=True
  
	Set dictTmp=CreateObject("Scripting.Dictionary")
	Set dictExists=CreateObject("Scripting.Dictionary")
	Set dictPreserve=CreateObject("Scripting.Dictionary")
	
	'Progress Counter
	g_InitObj = ""
	g_LogInset = 0

	If IsObject(dictInitGlobal) Then 
		Dim fCall, aFCall
		aFcall = dictInitGlobal.Keys
		For Each fCall in aFCall
			Dim sCParam
			sCParam = dictInitGlobal.Item(FCall)
			Dim sEval
			sEval = CStr(fCall)' & "(" & sCParam & ")") 
		
			Dim ehwhat
			ehwhat = CBool(Eval(sEval))
				
		Next
		Call dictInitGlobal.RemoveAll	
	Else
		Call Writelog("No dictInitGlobal Object Found")
	End If
	Init=True
	

End Function
		
Function InitFPDB()
		
  ' returns False if a connection could not be established. 
  ' returns True if connection is already open or opening the connection was successful

  On Error Resume Next
  
  Dim sConnstr
  
  InitFPDB = True
 
  If Not IsAlive(conn) then
    Writelog("connection object failure")
    InitFPDB=False
    Exit function
  End if
 
  If conn.State=1 then Exit Function
    
  'Attempt fips decryption 
  bRes = RRState.SecureCallAA("6307014535117033284","1479580647013172860",g_sFPDBDSN,sConnstr)   
  If bRes=False Then Writelog("Value not Decrypted.")
        
  Call Writelog("Opening Fingerprint DB")
  conn.Open(FormatADOConn(sConnstr))
	  
  If conn.State<>1 Or TrapError("Open Connection") Then 
    InitFPDB=False
    Writelog("WARNING: Fingerprint Database connection could not be established!")
  Else
    Writelog("Fingerprint/Rules Database connection established.")
	End If
    
  
End Function
		
Function GlobalInit()
		
    Dim loP
    Dim loCurrObj
    Dim strDSN
    Dim sWrkKey
    Dim sAppKey
    Dim sGenKey
    Dim slocale
    
    strDSN=""
  
    On Error Resume Next
  
    'Check for locale setting in DCO then AppSvc
    Call AppSvc_getlocale()     
	      
    set loP = CurrentObj

    'Check for AppSvc Fingerprint connection string value
    If IsAlive(RRState.Application) then
	    Writelog("Retrieving Fingerprint DB Connection string from Application Service")
			
		  'look for workflow name 
		  sWrkKey="*/dco_" & RRState.WorkflowName & "/fingerprintconn:cs"
		  Writelog("Looking for AppSvc Workflow Name key: '" & sWrkKey & "'")
		  Call RRState.Application.vbGetKeyValue(sWrkKey,0,False,strDSN)
		  If len(strDSN)>0 then
		      Writelog("AppSvc Workflow fingerprintconn found.")
              GlobalInit = Init(strDSN, gbInter, gbDebug, "TemplateID")
              Exit Function
          Else
              Writelog("No AppSvc Workflow Name key found.")
          End If
		
		  'look for app name 
		  sAppKey="*/dco_" & RRState.ApplicationName & "/fingerprintconn:cs"
		  Writelog("Looking for AppSvc Application Name key: '" & sAppKey & "'")
		  Call RRState.Application.vbGetKeyValue(sAppKey,0,False,strDSN)
		  If len(strDSN)>0 then
			  Writelog("AppSvc Application name fingerprintconn.")
              GlobalInit = Init(strDSN, gbInter, gbDebug, "TemplateID")
              Exit Function
          Else
              Writelog("No AppSvc Application Name key found.")
          End If
		
		  'look for general name
		  sGenKey="*/fingerprintconn:cs"
		  Writelog("Looking for AppSvc General key: '" & sGenKey & "'")
	      Call RRState.Application.vbGetKeyValue(sGenKey,0,False,strDSN)
	      If len(strDSN)>0 then
              GlobalInit = Init(strDSN, gbInter, gbDebug, "TemplateID")
              Exit Function
          Else
              Writelog("No AppSvc General key found.")
          End If
           
	End if

	While IsObject(loP) And Not(loP Is Nothing)
		set loCurrObj = Nothing
		set loCurrObj = loP
		set loP = Nothing
		set loP = loCurrObj.Parent()
	Wend

	If IsObject(loCurrObj) And Not(loCurrObj Is Nothing) then
		strDSN = loCurrObj.Variable("FingerprintConn")
        If len(trim(strDSN))>0 then
    		    WriteLog("Fingerprint Database Connection String Found.")
        Else
            Writelog("No Fingerprint Database Connection String was found in the Setup DCO.")
	    End if
        GlobalInit = Init(strDSN, gbInter, gbDebug, "TemplateID")
	End if


End Function
		
Function AppSvc_getlocale()
		

     On Error Resume Next

     Dim slocale

    'Check for locale setting in DCO then AppSvc
    slocale = DCO.Variable("hr_locale")
    
    If slocale = "" or slocale="-1" and IsAlive(RRState.Application) then
     
      Writelog("Retrieving locale setting from Application Service")
			
		  'look for workflow name 
		  sWrkKey="*/dco_" & RRState.WorkflowName & "/locale"
		  Writelog("Looking for AppSvc Workflow Name key: '" & sWrkKey & "'")
		  Call RRState.Application.vbGetKeyValue(sWrkKey,0,False,slocale)
		  If len(slocale)>0 then 
        DCO.Variable("hr_locale")=slocale
        Writelog("Batch locale set to '" & slocale & "' from Application Service.") 
        Exit Function
		  End if
      slocale=""
      
		  'look for app name 
		  sAppKey="*/dco_" & RRState.ApplicationName & "/locale"
		  Writelog("Looking for AppSvc Application Name key: '" & sAppKey & "'")
		  Call RRState.Application.vbGetKeyValue(sAppKey,0,False,slocale)
		  If len(slocale)>0 then 
        DCO.Variable("hr_locale")=slocale
        Writelog("Batch locale set to '" & slocale & "' from Application Service.") 
        Exit Function
		  End if
		  slocale=""
      
		  'look for general name
		  sGenKey="*/locale"
		  Writelog("Looking for AppSvc General key: '" & sGenKey & "'")
	    Call RRState.Application.vbGetKeyValue(sGenKey,0,False,slocale)
	    If len(slocale)>0 then 
        DCO.Variable("hr_locale")=slocale
        Writelog("Batch locale set to '" & slocale & "' from Application Service.") 
        Exit Function
		  End if          
                  
      Writelog("No locale setting found in the Application Service.") 

  End if
    
  
End Function
		GlobalInit()
Sub InsertFailStats(nTemp,nAction,sBatch,sImage,sResult) 
	Dim sSQL

	If Not g_bRuleStats = True Then Exit Sub

	If sBatch="" Or sImage="" Or sResult="" Then
		Writelog("Unable to insert statistic. Some fields empty.")
		Exit Sub
	End If
	
	On Error Resume Next

  If InitFPDB=False then Exit Sub

	If CLng(nTemp) < CLng(555) Then nTemp = CLng(555)	

	sSQL="INSERT INTO RULESTATS (ST_TEMPLATEID, ST_ACTIONID, ST_BATCHID, ST_IMAGE, ST_RESULT) VALUES (" &_
			CStr(nTemp) & ", " & CStr(nAction) & ", '" & sBatch & "', '" & sImage & "', '" & sResult & "');"
	
	Writelog(Space(5) & "Executing : " & sSQL)
	conn.Execute(sSQL)
	TrapError("InsertFailStats")

End Sub

Sub WriteDataFile(DcoObj) 
	Dim sDataFile
	Dim sExt
	Dim nTime
	nTime=timer	
		
	On Error Resume Next	
		
	sDataFile = ""
	exit sub
	If DcoObj.ObjectType=3 and DcoObj.Variable("DATAFILE")<>"" Then
		  If DcoObj.Write(DcoObj.Variable("DATAFILE")) = False then
        Writelog("Unable to Write file:'" & DcoObj.Variable("DATAFILE") & "' for object '" & DcoObj.ID & "'. ABORTING TASK. ")
        nTaskStatus = RetAbort
	    End if
  End if 
	
	If DcoObj.ObjectType <> 2 Then Exit Sub
	If DcoObj.NumOfChildren=0 Then Exit Sub
	
	sDataFile = DcoObj.Variable("DATAFILE")
	
	If sDataFile = "" Then
		sDataFile = DcoObj.Variable("IMAGEFILE")	
		sDataFile =	left(sDataFile,len(sDataFile)-3) & "xml"
		DcoObj.Variable("DATAFILE")=sDataFile	
	End if  
	  
	If DcoObj.Write(sDataFile)=False Then
		 Writelog("Unable to Write file:'" & sDataFile & "' for object '" & DcoObj.ID & "'. ABORTING TASK ")
     nTaskStatus = RetAbort
	End if
	Writelog("Write File eTime:" & cstr(rr_eTimer(ntime)))

End Sub

Function Quit()
		
	
  bReturn=true
    
	If bReturn=False then 
		Call AbortBatch()
		RRState.Data("nTaskStatus")=RetAbort
		Call Writelog("ERROR Writing '" & Pilot.Dcofile & "' Data files. Aborting.")
		Call Writelog("DCO Last Error:'" & DCO.GetLastError() & "'.")
	End if

  On Error Resume Next
  
  If IsAlive(conn)Then
		If conn.State=1 Then conn.Close()
	End If
  Set conn=Nothing
  
  If IsAlive(oConn)Then
		If oConn.State=1 Then oConn.Close()
	End If
  Set oConn=Nothing
  
  If IsAlive(g_DCSmart) then g_DCSmart.DatacapRRCleanupTime = true
  Set g_DCSmart = Nothing
  
	Set CCOCreator=Nothing
  Set CCO=Nothing
  
  Call dictExits.RemoveAll()
	Set dictExists=Nothing
  
  Call dictTmp.RemoveAll()
	Set dictTmp=Nothing
	  
  Call dictPreserve.RemoveAll()
  Set dictPreserve=Nothing
    
  Call dictInitGlobal.RemoveAll()
  Set dictInitGlobal=Nothing
  
  Call g_RRnDocDict.RemoveAll()
  Set g_RRnDocDict=Nothing
  
  Call dictDCOGlobal.RemoveAll()
  Set dictDCOGlobal=Nothing
  
  Set g_DCSmart = Nothing

  Set DCGlobalStrings = Nothing
  Set DCGlobalDates = Nothing
  Set DCGlobalCurrency = Nothing
  Set DCGlobalLocale = Nothing
  Set DCGlobalBidi = Nothing
  
  If IsAlive(RRLogic) then
     RRLogic.DatacapRRCleanupTime = true
  End If
  Set RRLogic = Nothing
  
  Set FileMgr = Nothing
  Set ImageCtrl = Nothing
  Set oConn = Nothing
  Set oFsys = Nothing
  Set rr_xDom = Nothing  

  'Clear errors from cleanup
  Err.Clear
  

End Function
		
Function TrapError(sFrom)
		
	TrapError=False
	
	If Err.number=0 Then
		Exit Function
	End If

	sMessage="*** Error #'" & CStr(Err.Number) & "' (" & Err.Description & ") in sub/function:" & sFrom 
	Call Writelog(sMessage)
	
	Err.Clear
	TrapError=True
	


End Function
		
Function DBErrTrap(ConnectionObj,sDescription)
		
	Dim sStr
	Dim oErr
	Dim sNumString	

	DBErrTrap = False
	
	If ConnectionObj.Errors.Count > 0 Then
		sStr = vbCrLf
		sNumString = ""

		For Each oErr In ConnectionObj.Errors
		
      Select Case cstr(oErr.Number)
      
        Case "0","265929","-2147217887" 
			
				Call WriteLog("DB Connection WARNING! Err number: " & oErr.Number & "  Desc: " & oErr.Description)
				ConnectionObj.Errors.Clear
				DBErrTrap = False
				Exit Function
			  
        Case Else	
				  sNumString = sNumString & oErr.Number & Space(1)
        
			End Select
		
			Call WriteLog("*------------------- DATABASE ERROR ------------------")			
			Call WriteLog("* " & sDescription)
			Call WriteLog("* Description: " & oErr.Description)
	 		Call WriteLog("*  Numeric ID: " & CStr(oErr.Number)) 
			Call WriteLog("* Data Source: " & oErr.Source)
	   		Call WriteLog("*-------------------- DATABASE ERROR -----------------")
   		 	
	 	Next 'Err  	
	 	  		
 		DBErrTrap = True
 		ConnectionObj.Errors.Clear
   		If ConnectionObj.Errors.Count <> 0 Then Call Writelog("Error Obj Not Cleared") 
		sDescription = sNumString
 	End If	

End Function
		
'================================== Action Utility Functions =================

Function WriteLog(byval txtmsg)
		

		If IsAlive(DCLogX) Then	Call DCLogX.Write(Space(1) & txtmsg)


End Function
		
Function DeBugLog(byval txtmsg)
		

	If Not bDebug Then Exit Function

		If IsAlive(DCLogX) Then	Call DCLogX.Write(Space(1) & txtmsg)


End Function
		
Function Convert4Xml(sTextMsg)
		
	Convert4Xml = Replace(sTextMsg    ,"&", "&amp;") 
	Convert4Xml = Replace(Convert4Xml ,"<", "&lt;") 
	Convert4Xml = Replace(Convert4Xml ,">", "&gt;") 	 
	Convert4Xml = Replace(Convert4Xml ,"'", "&apos;")
	Convert4Xml = Replace(Convert4Xml ,Chrw(34),"&quot;")

End Function
		
Function DCOMessage(txtmsg)
		

	On Error Resume next
		
	If Not CurrentObj.AddVariable("MESSAGE",txtmsg) Then 
		CurrentObj.Variable("MESSAGE") = txtmsg
	End If


End Function
		
Function lenT(value)
		
      lenT=-1
      
      if IsAlive(DCGlobalStrings) then
        LenT=clng(DCGlobalStrings.LengthInTextElements(value))
      End if
      
      
End Function
		
Function InstrT(searchin,searchfor,startindex,compareoption)
		
      InstrT=-1 
      
      startindex=cint(startindex)
      compareoption=cint(compareoption)
      
      if IsAlive(DCGlobalStrings) then
        InstrT=clng(DCGlobalStrings.InstrTextElements(searchin, searchfor, startindex, compareoption))
      End if
      
      
End Function
		
Function rr_EscapeRegExProtectedChars(FindStr)
		
        
  'Check for and protect against RegEx reserved characters 
       
  On Error Resume Next

  FindStr = Replace(FindStr,"*","\*")
  FindStr = Replace(FindStr,"\","\\")
  FindStr = Replace(FindStr,"^","\^")
  FindStr = Replace(FindStr,"$","\$")
  FindStr = Replace(FindStr,"+","\+")
  FindStr = Replace(FindStr,"?","\?")
  FindStr = Replace(FindStr,".","\.")
  FindStr = Replace(FindStr,"[","\[")
  FindStr = Replace(FindStr,"]","\]")
  FindStr = Replace(FindStr,"(","\(")
  FindStr = Replace(FindStr,")","\)")
  FindStr = Replace(FindStr,"|","\|")
  FindStr = Replace(FindStr,"{","\{")
  FindStr = Replace(FindStr,"}","\}")
  FindStr = Replace(FindStr,",","\,")
  FindStr = Replace(FindStr,"-","\-")

  'pm_removeprotectedchars=FindStr
  rr_EscapeRegExProtectedChars = FindStr


End Function
		
Function MessageID(Message,Identifier)
		

	On Error Resume next
		
	CurrentObj.Variable("MESSAGE") = Message
	
  Identifier = Trim(Identifier)
  If len(Identifier)>0 then
  		  CurrentObj.Variable("MessageID") = Identifier
	End if
  

End Function
		
Function MessageIDParameter(Value,ValueType,Index)
		

	On Error Resume next
	
  MessageIDParameter=True
  
  Dim sParamName
  Dim sParamType
  sParamText = "MessageParamText_" & cstr(Index) 'MessageParamText_0'
  sParamType = "MessageParamType_" & cstr(Index) 'MessageParamType_0'
  
  Dim ResolvedValue
  Dim RX
  Dim sMessage
  Dim bTypes
  bTypes=False
  
  'permitted 'Type' values:
  Dim Types
  Types = Array("job", "task", "shortcut", "field", "workflow", "appname", "pagetype", "doctype", "text", "variable")    
  
  'check Type is a an allowed value 
  For t = 0 to (ubound(Types)-1)
    If lcase(ValueType)=Types(t) Then
      bTypes=True
      Exit For
    End if
  Next 't
  
  If (BTypes=False) Then
    Writelog("Type '" & ValueType & "' is not a member of the allowed types:'" & Join(Types,",") & ".")
    Exit Function
  End if
  
  'check for duplicate Parameter index     
  If CurrentObj.FindVariable(sParamText)>=0 or CurrentObj.FindVariable(sParamType)>=0 Then
    Writelog("Reusing Parameter index. Existing value '" & CurrentObj.Variable(sParamText) & "' and type '" &  CurrentObj.Variable(sParamType) & "' will be replaced.")
  end if
  
  'save MessageParamType variable & value to DCO node
  CurrentObj.Variable(sParamText) = Value
  CurrentObj.Variable(sParamType) = ValueType
       
  'resolve values as allowed; eg SmartParameter
  Writelog("Resolving Value '" & Value & "'...")
  ResolvedValue = MetaWord(Value)
  If Len(ResolvedValue) = 0 Then ResolvedValue = Value 
  
  'Perform Message Substitution
  sMessage = CurrentObj.Variable("MESSAGE")
  If Len(sMessage)=0 then
    Writelog("The 'MESSAGE' variable is empty. Exiting Action.")
    Exit Function
  Else
    Writelog("Current 'MESSAGE' value:'" & sMessage & "'.")
  End if
  
  Dim sPattern
  sPattern = "{" & cstr(Index) & "}"
  
  writelog("pattern:'" &  sPattern & "'.")
  'sResult = DCGlobalStrings.RemoveReplace(sMessage,cint(nStartIndex-1),sInsertString,cint(nMaxMatches), CurrentObj)
	sNewMessage = Replace(sMessage, sPattern, ResolvedValue)
  writelog("replace:" & sNewMessage)  
    
  If Trim(sMessage) <> Trim(sNewMessage) then
    sMessage = sNewMessage
    Writelog("Substitution successful. New 'MESSAGE' value: '" & sMessage & "'.")
  Else
    Writelog("A Substitution was not successfull. Please check your settings if a substitution was supposed to occur.")
	End if
  
  'save MessageParamText variable & value to DCO node
  CurrentObj.Variable("MESSAGE") = sMessage
  CurrentObj.Variable(sParamText) = ResolvedValue
  

End Function
		
Function GetFieldValue()
		

	If Not IsObject(CurrentObj) Or CurrentObj Is Nothing Then Exit Function
	
	If CurrentObj.ObjectType<3 Then 
		GetFieldValue = CurrentObj.Variable("Text")
	Else
		GetFieldValue = CurrentObj.Text
	End if


End Function
		
Function GetFieldConf()
		

	If Not IsObject(CurrentObj) Or CurrentObj Is Nothing Then Exit Function
		 
	GetFieldConf = CurrentObj.ConfidenceString
	

End Function
		
Function SetFieldValue(NewValue)
		

		Exit Function
	

End Function
		
Function GetProjectName()
		
	If strProjectName = "" Then
		strPath = Trim(Pilot.ProjectPath)
		strExt = FileMgr.GetExtensionName(strPath)
		If strPath <> "" Then
			strProjectName = Left(strPath,Len(strPath)-Len(strExt)-1)
		End If
	End If
	GetProjectName = strProjectName

End Function
		
Sub ErrorHandler(DescString) 
	Dim eStr

	If Err.Number <> 0 Then		
		Writelog(" ")
		Writelog(String(60,"*"))
		Writelog("*       ERROR! --> '" & DescString & "' ")
		Writelog("* DESCRIPTION: " & Err.Description)
		Writelog("*  NUMERIC ID: " & CStr(Err.Number))
		Writelog("*      SOURCE: " & Err.Source)
		Writelog(String(60,"*"))
		Writelog(" ")
		
		If g_bAbortOnError=True Then nTaskStatus = RetAbort
		
		Err.Clear
	End If


End Sub

Function ShowRect(leftX,topY,rightX,bottomY)
		
	If nRectIndex>-1 Then
		Call ImageCtrl.EraseRect(nRectIndex)
	End If

	nRectIndex = ImageCtrl.DrawRect(leftX-2,topY-2,rightX+2,bottomY+2,3,RGB(0,0,255),RGB(255,0,0),"")

	'refreshes the image
	ImageCtrl.Zoom = ImageCtrl.Zoom 
	
	ShowRect = True

End Function
		
Function PreserveStatus(bInter,bDebug,bOFF)
		
	nPreserve=bOFF

  	If Not dictPreserve.Exists(g_nRuleType) Then 
  		Call dictPreserve.Add(g_nRuleType,nPreserve)
  	Else
  		dictPreserve(g_nRuleType) = nPreserve
  	End If
  
	PreserveStatus = nPreserve

End Function
		
Function ObjectCount(Obj,ObjType)
		
	Dim nCount
	Dim I
	Dim sObj
	
	ObjectCount=cint(0)
	
	Set sObj=Obj
	If sObj.ObjectType = ObjType Then
		ObjectCount=cint(1)
	Else
		If sObj.ObjectType < ObjType Then
			nCount=sObj.NumOfChildren
			For I=0 To nCount-1
				ObjectCount=ObjectCount + Cint(ObjectCount(sObj.GetChild(I),ObjType))
			Next
		End If
	End If
	Set sObj = Nothing

End Function
		
Function IsAlive(vbObj)
		
	IsAlive=False
	If IsEmpty(vbObj) Then
		Exit Function
	End If
	If IsObject(vbObj)=False Then
		Exit Function
	End If
	If vbObj Is Nothing Then
		Exit Function
	End If
	IsAlive=True

End Function
		
Function ProcessChildrenFirst(bInter,bDebug)
		
	bGoUp = True
	ProcessChildrenFirst = True

End Function
		
Function FormatADOConn(strParam)
		
	Dim sConnStr
	Dim sProvider
	Dim sDSN
	Dim sCatalog
	Dim sUID
	Dim sPWD
	Dim sDBNTA
	Dim aConnParse
	Dim i
	Dim RX
	Dim sTEST

	On Error Resume Next
	
	FormatADOConn = strParam
				
	'Find Connection Sections via Keywords	
	Set RX = CreateObject("VBScript.RegExp")
	RX.IgnoreCase = True
	RX.Global = True
	
	aConnParse = Split(strParam,";")
	
	For i = 1 to (ubound(aConnParse)+1)
		  RX.Pattern=" *PROVIDER *="
		  If RX.Test(aConnParse(i-1)) then
			  sProvider = Trim(RX.replace(aConnParse(i-1),""))
		  End if

      RX.Pattern = " *CATALOG *="
		  If RX.Test(aConnParse(i-1)) then
			  sCatalog = trim(RX.replace(aConnParse(i-1),""))
		  End if

      RX.Pattern = " *DBNTA *="
		  If RX.Test(aConnParse(i-1)) then
			  sDBNTA = trim(RX.replace(aConnParse(i-1),""))
		  End if

		  RX.Pattern = " *DSN *="
		  If rx.Test(aConnParse(i-1)) then
			  sDSN = trim(RX.replace(aConnParse(i-1),""))
		  End if
              
      RX.Pattern = " *UID *="
		  If rx.Test(aConnParse(i-1)) then
			  sUID = trim(RX.replace(aConnParse(i-1),""))
		  End if
         
      RX.Pattern = " *PWD *="
		  If rx.Test(aConnParse(i-1)) then
			  sPWD = trim(RX.replace(aConnParse(i-1),""))
		  End if
  		
      RX.Pattern = " *SQLTEST *="
      If rx.Test(aConnParse(i-1)) then
		    sTEST = RX.replace(aConnParse(i-1),"")
		  End if
	Next 'i

    'Remove SQLTEST entry	
    RX.Pattern = " *SQLTEST *=" & sTEST & ";"
    strParam = trim(RX.replace(strParam,""))
       
    Set RX = Nothing

    If Ucase(Trim(sTEST))="YES" or Ucase(Trim(sTEST))="1" then
        writelog("Passthrough FormatADOConn string:'" & strParam & "' ")    
	      FormatADOConn = strParam  
        Exit Function
    End if

	Select Case Ucase(sProvider)
		Case "MSSQL"
			sConnStr = "Provider=SQLOLEDB;Server=" & sDSN & ";Database=" & sCatalog & ";"
			If Ucase(sDBNTA) = "YES" Then
				sConnStr = sConnStr & "Integrated Security=sspi;"
				sPWD=""
				sUID=""
            Else
                sConnStr = sConnStr & "UID=" & sUID & ";PWD=" & sPWD & ";"
			End if
		Case "MSACCESS"
			sConnStr = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" & sDSN & ";"
		Case "ORACLE"
			sConnStr = "Provider=OraOLEDB.Oracle;Data Source=" & sDSN & ";" 
			sConnStr = sConnStr & "User Id=" & sUID & ";"
			sConnStr = sConnStr & "Password=" & sPWD & ";"
			
		Case "MSORACLE"
			sConnStr = "Provider=MSDAORA;Data Source=" & sDSN & ";"
			sConnStr = sConnStr & "User Id=" & sUID & ";"
			sConnStr = sConnStr & "Password=" & sPWD & ";"

		Case "ODBCMSSQL","ODBCMSACCESS","ODBCORACLE","ODBCMSORACLE"
			sConnStr = "DSN=" & sDSN & ";UID=" & sUID & ";PWD=" & sPWD & ";"
		Case ""
			If len(sDSN)=0 and ubound(aConnParse)=0 then sConnStr = "DSN=" & strParam & ";"
		Case Else
			'Other provider string!
			sConnStr = strParam
	End Select
	
	FormatADOConn = sConnstr


End Function
		
Function FormatTMConn(strParam)
		
	Dim sConnStr
	Dim sProvider
	Dim sDSN
	Dim sDataSource
	Dim sDatabase
	Dim sCatalog
	Dim sUID
	Dim sPWD
	Dim sDBNTA
	Dim aConnParse
	Dim i
	Dim RX


	On Error Resume Next

	FormatTMConn = strParam
				
	'Find Connection Sections via Keywords	
	Set RX = CreateObject("VBScript.RegExp")
	RX.IgnoreCase = True
	RX.Global = True
	
	strParam = strParam & ";"
	aConnParse = Split(strParam,";")
	
	For i = 1 to ubound(aConnParse)
  
		RX.Pattern = " *DATASOURCE *="
    If RX.Test(aConnParse(i-1)) then  
			sDataSource = trim(RX.replace(aConnParse(i-1),""))		
		End if	

		RX.Pattern = " *DATABASE *="
    If RX.Test(aConnParse(i-1)) then
      sDatabase = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *PROVIDER *="
    If RX.Test(aConnParse(i-1)) then  
			sProvider = Trim(RX.replace(aConnParse(i-1),""))
		End if
		
		RX.Pattern = " *CATALOG *="
    If RX.Test(aConnParse(i-1)) then  
			sCatalog = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *DBNTA *="
    If RX.Test(aConnParse(i-1)) then  
			sDBNTA = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *DSN *="
    If RX.Test(aConnParse(i-1)) then  
			sDSN = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *UID *="
    If RX.Test(aConnParse(i-1)) then  
			sUID = trim(RX.replace(aConnParse(i-1),""))
		End if
    
		RX.Pattern = " *PWD *="
    If RX.Test(aConnParse(i-1)) then  
			sPWD = trim(RX.replace(aConnParse(i-1),""))
		End if
	Next 'i

	Set RX = Nothing

	Select Case UCase(sProvider)
		Case "SQLOLEDB"
			sConnStr = "PROVIDER=MSSQL;DSN=" & sDSN & ";CATALOG=" & sDatabase & ";"
			If instr(ucase(strParam),"SSPI")>0  Then
				sConnStr=sConnStr & "DBNTA=yes;"
			Else
				sConnStr=sConnStr & ";UID=" & sUID & ";PWD=" & sPWD & ";"
			End if
		Case "MICROSOFT.JET.OLEDB.4.0"
			sConnStr = "PROVIDER=MSACCESS;DSN=" & sDataSource & ";UID=" & sUID & ";PWD=" & sPWD & ";"
		Case "ORAOLEDB.ORACLE"
			sConnStr = "PROVIDER=ORACLE;DSN=" & sDataSource & ";UID=" & sUID & ";PWD=" & sPWD & ";"
		Case "MSDAORA"
			sConnStr = "PROVIDER=MSORACLE;DSN=" & sDataSource & ";UID=" & sUID & ";PWD=" & sPWD & ";"			
		'Case "ODBCMSSQL","ODBCMSACCESS","ODBCORACLE","ODBCMSORACLE"
		'	sConnStr = "DSN=" & sDSN & ";UID=" & sUID & ";PWD=" & sPWD & ";"
		Case ""
			If len(sDSN)=0 and ubound(aConnParse)=0 then 
				sConnStr = "PROVIDER=ODBCMSACCESS;DSN=" & strParam & ";"
			Else
				sConnStr = "PROVIDER=ODBCMSACCESS;DSN=" & strParam & ";UID=" & sUID & ";PWD=" & sPWD & ";"
			End if
		Case Else
			'Other provider string!
			sConnStr = strParam
			Writelog("String may not be a valid aTM connection string.")
	End Select
	
	'writelog("FormatTMConn string:'" & sConnstr & "' ")
	FormatTMConn =  sConnstr	
	

End Function
		
Function CheckAnchor(bInter,bDebug,strParam)
		
	Dim oAnc
	CheckAnchor = False
	
	Set oAnc = CurrentObj.FindChild(strParam)

	If oAnc Is Nothing Then
		WriteLog("Anchor field (" & strParam & ") not found!")
		Exit Function
	Else
		rtn = oAnc.GetPosition(A,B,C,D)

		If Not rtn Or (A+B+C+D) <= 0 Then
			Writelog("Anchor field (" & strParam & ") position not set!")
			Exit Function
		End If
		CheckAnchor = True
	End If

	Set oAnc = Nothing

End Function
		
Function CheckDICT(DCOobject)
		
	Dim FieldValue
	
  If DCOObject.Objecttype<DCO_Field then
    CheckDICT = DCOObject.Variable("Text")
  Else
    CheckDICT = DCOobject.Text
	End if
	
	FieldValue = u_DCODict(DCOobject,1)
  
  If len(FieldValue)>0 then CheckDICT=FieldValue


End Function
		
Function u_DCODict(DCONode,DictType)
		
	
  On Error Resume Next

  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 
  
  u_DCODict=g_DCSmart.u_DCODict(DCONode,DictType)
  

End Function
		
Sub RRCopyChars(oSource,oDest,nStart,nLen) 
  ' Merges Characters from oSource to oDest (DCO Field) nodes
  ' Includes character position and confidence information
  ' NOTE: WILL APPEND TO EXISTING CHARACTERS IN oDEST node!!
	
	Dim x,y
	Dim cObj_S
	Dim cObj_D
	Dim nFields
	Dim Cleft ,Ctop ,Cright ,Cbottom
	Dim Fleft ,Ftop ,Fright ,Fbottom
	Dim SPos, aPosition
		
	If oSource is Nothing then Exit Sub
	If oDest is Nothing then Exit Sub
	If Not Isnumeric(nstart) then Exit Sub
	If Not Isnumeric(nLen) then Exit Sub

	Fleft = ""
	Ftop = ""
	Fright=""
	Fbottom=""
	
	On Error Resume Next
	
	'Character Index begins after any child fields
	nFields = oSource.NumOfChildren - len(oSource.Text)

	nStart=nStart+nFields

	For x = nStart to (nLen+nStart-1)
		Set cObj_S = oSource.GetChild(x-1)
		Set cObj_D = oDest.AddChild(4,"",-1)
		
		If Not cObj_S is Nothing and Not cObj_D is Nothing then 
					
			cObj_D.CharValue(0)= cObj_S.CharValue(0)
			cObj_D.CharConfidence(0) = cObj_S.CharConfidence(0)

			SPos=cObj_S.Variable("Position")
			cObj_D.Variable("Position")=SPos	
			
			aPosition = Split(SPos, ",")
			For i=0 To UBound(aPosition)
				aPosition(i)=CLng(aPosition(i))
			Next

			If Ubound(aPosition)>=3 Then
				Cleft=aPosition(0)
				Ctop=aPosition(1)
				Cright=aPosition(2)
				Cbottom=aPosition(3)
			End if
				
			If Not(Cleft=0 and Ctop=0 and Cright=0 and Cbottom=0) Then 			
						
				If Fleft="" then FLeft=Clng(Cleft)
				If Clng(Cleft)<Fleft then FLeft=Clng(Cleft)
				If Ftop="" then Ftop=Clng(Ctop)
				If Clng(Ctop)<Ftop then Ftop=Clng(Ctop)
				If Fright="" then Fright=Clng(Cright)
				If Clng(Cright)>Fright then Fright=Clng(Cright)
				If Fbottom="" then Fbottom=Clng(Cbottom)
				If Clng(Cbottom)>Fbottom then Fbottom=Clng(Cbottom)
	
			End if
		End if
	Next 'x

	If Fleft="" then FLeft=Clng(0)		
	If Ftop="" then Ftop=Clng(0)
	If Fright="" then Fright=Clng(0)
	If Fbottom="" then Fbottom=Clng(0)

	oDest.Variable("Position") = cstr(Fleft) & "," & cstr(Ftop) & "," & cstr(Fright) & "," & cstr(Fbottom)
	Set cObj_S = Nothing
	Set cObj_D = Nothing
	

End Sub

Sub RRCopyPos(oSource,oDest,nStart,nLen) 
' Merges Positions from oSource to oDest (DCO Field) nodes
' NOTE: WILL APPEND TO EXISTING POSITION IN oDEST node!!	
	
	Dim x,y
	Dim cObj_S
	Dim cObj_D
	Dim nFields
	Dim Cleft ,Ctop ,Cright ,Cbottom
	Dim Fleft ,Ftop ,Fright ,Fbottom
	Dim FPosition
		
	If oSource is Nothing then Exit Sub
	If oDest is Nothing then Exit Sub
	If Not Isnumeric(nstart) then Exit Sub
	If Not Isnumeric(nEnd) then Exit Sub

	Fleft = ""
	Ftop = ""
	Fright=""
	Fbottom=""

	'Character Index begins after any child fields
	nFields = oSource.NumOfChildren - len(oSource.Text)

	'Find Current Position Info
	FPosition = oDest.Variable("Position")
	If FPosition = "0,0,0,0" then FPosition = ""
	aPosition = Split(FPosition, ",")
	For i=0 To UBound(aPosition)
		aPosition(i)=CLng(aPosition(i))
	Next

	If Ubound(aPosition)>=3 Then
		Fleft=aPosition(0)
		Ftop=aPosition(1)
		Fright=aPosition(2)
		Fbottom=aPosition(3)
	End if
	
	nStart=nStart+nFields
	
	For x = nStart to (nLen+nStart-1)
		Set cObj_S = oSource.GetChild(x-1)
				
		If Not cObj_S is Nothing then 
							
			SPos=cObj_S.Variable("Position")
						
			aPosition = Split(SPos, ",")
			For i=0 To UBound(aPosition)
				aPosition(i)=CLng(aPosition(i))
			Next

			If Ubound(aPosition)>=3 Then
				Cleft=aPosition(0)
				Ctop=aPosition(1)
				Cright=aPosition(2)
				Cbottom=aPosition(3)
			End if
			
			If Not(Cleft=0 and Ctop=0 and Cright=0 and Cbottom=0) Then 			
						
				If Fleft="" then FLeft=Clng(Cleft)
				If Clng(Cleft)<Fleft then FLeft=Clng(Cleft)
				If Ftop="" then Ftop=Clng(Ctop)
				If Clng(Ctop)<Ftop then Ftop=Clng(Ctop)
				If Fright="" then Fright=Clng(Cright)
				If Clng(Cright)>Fright then Fright=Clng(Cright)
				If Fbottom="" then Fbottom=Clng(Cbottom)
				If Clng(Cbottom)>Fbottom then Fbottom=Clng(Cbottom)
	
			End if
		End if
	Next 'x

	If Fleft="" then FLeft=Clng(0)		
	If Ftop="" then Ftop=Clng(0)
	If Fright="" then Fright=Clng(0)
	If Fbottom="" then Fbottom=Clng(0)
				
	oDest.Variable("Position") = cstr(Fleft) & "," & cstr(Ftop) & "," & cstr(Fright) & "," & cstr(Fbottom)
	Set cObj_S = Nothing
	

End Sub

Sub RRCopyImage(oSource,oTarget) 
	
' Ensures that the target field's child fields will retain the correct IMAGEFILE properties 
' when overwriting the target with data from a page other than its original.
	
	
	Dim nChildren
	Dim oChild	
		
	If oTarget.Variable("Position")="0,0,0,0" then oTarget.Variable("Position")=oSource.Variable("Position")
	If oTarget.Variable("IMAGEFILE")<>oSource.Variable("IMAGEFILE") Then
				
		'Update Child Fields with correct IMAGEFILE Variable. Must be performed before updating parent field, or 
		'child will reflect same ImageFile value as Target field. Only update child if child is same value as 
		'parent because child may have different ImageFile as parent.
				
		nChildren = oTarget.NumOfChildren - Len(oTarget.Text)
		For n = 1 to nChildren
			Set oChild = oTarget.GetChild(n-1)
			If Not(oChild is Nothing) Then
				If oChild.Variable("IMAGEFILE")=oTarget.Variable("IMAGEFILE") Then
					oChild.Variable("IMAGEFILE")=oTarget.Variable("IMAGEFILE")
					If len(Trim(oTarget.Variable("IMAGEHEIGHT")))<>"" then oChild.Variable("IMAGEHEIGHT")=oTarget.Variable("IMAGEHEIGHT")
				End if
			End if
		Next 'oChild
		Set oChild=Nothing
		
		oTarget.Variable("IMAGEFILE")=oSource.Variable("IMAGEFILE")
		If len(trim(oSource.Variable("IMAGEHEIGHT")))<>"" Then oTarget.Variable("IMAGEHEIGHT")=oSource.Variable("IMAGEHEIGHT")
	End if
	

End Sub

' DCO NAVIGATION

Function RReturnNamedComponent(byVal sFindObjID)
		
' Finds First Object matching ID by first searching children of 
' the calling object. If the calling object is a field the search will 
' check through each level in the current page back to the parent page.
' If the calling object is a page, the function will check back to the 
' parent document.
' Sets the ObjectType backwards search limit.

	Dim oNode	
	Dim iNum
	Dim rNode
	Dim iType
	Dim VarId
	Dim aObjID	
	
	
	On Error Resume Next
	
	
	iType = 2

	Set RReturnNamedComponent = Nothing
	Set oNode = CurrentObj

	If Not IsObject(oNode) Then Exit Function
	
	'If the calling object is a page, set the backlimit to the document.
	If oNode.ObjectType = 2 Then iType = 1
		
	'Check for & strip out variable name in sFindObjID argument. 
	'Flag is the Decimal '.' character (period).
		VarID = DCOFindVar(sFindObjID)
    If len(VarID)>0 then
        ObjID = replace(sFindObjID,"."&VarID,"")
    Else
        ObjID = sFindObjID
    End if
			
	'Check Each node Level Back to Parent Page	 
	While oNode.ObjectType >= iType
				 
		If oNode.Type = ObjId Then
			Set RReturnNamedComponent = oNode
			Set oNode = Nothing
			Exit Function
		End if	
			
		Set rNode = rr_SearchChildren(oNode, ObjID)

		If Not(rNode Is Nothing) Then 
			Set RReturnnamedcomponent = rNode
			Set rNode = Nothing
			Set oNode = Nothing	
			Exit Function
		End If

		Set oNode = oNode.Parent()			
		If Not IsObject(oNode) Then 
			Set oNode = Nothing
			Exit Function
		End if

	Wend

	Set rNode = Nothing
	Set oNode = Nothing
		

End Function
		
Function RReturnNamedValue(byVal sFindObjID)
		
	Dim oNode
	Dim iNum
	Dim rtnObj
	Dim iType
	Dim VarId
	Dim aObjID	
	
	On Error Resume Next
	
	Set oNode = Nothing
			
	'Check for variable in sFindObjID argument. Flag is the Decimal '.' character (period).
	VarID = DCOFindVar(sFindObjID)
		
	Set oNode = RReturnNamedComponent(sFindObjID)	
		
	If Not(oNode Is Nothing) Then 
		If Len(VarID)=0 then
			RReturnNamedValue = CheckDICT(oNode)
		Else
			RReturnNamedValue = oNode.Variable(VarID)
		End if
	End If

	Set oNode = Nothing
			

End Function
		
Function rr_SearchChildren(oDCO,byVal ObjID)
		
	Dim i
	Dim oDCOChild
		
	Set rr_SearchChildren = Nothing

	For i = 1 To (oDCO.NumOfchildren-Len(oDCO.Text))
		Set oDCOChild = oDCO.GetChild(i-1)
			
		If IsObject(oDCOChild) Then
			If oDCOChild.Type = ObjID Then
				Set rr_SearchChildren = oDCOChild
				Exit Function			
			End If
				
			If Len(oDCOChild.Text) <> oDCOChild.NumOfChildren Then 
				Set rr_SearchChildren = rr_SearchChildren(oDCOChild, ObjID)								
			End If

			If Not IsObject(rr_SearchChildren) Then Exit Function
		End If
	Next 'i


End Function
		
'New META UTILITY FUNCTIONS:

Function DCONav(sFindNode)
		
'Utility Function Returns DCO object based on Metacharacter string
'Special Characters:
'   a) ..\	navigate back 1 node (parent node)
'   b) .	value following period is a variable name - ignored in this function
'   c) \	next node (child)
'	d) @B	Root Batch Node
'	e) @D Root Document Node
'	f) @P	Root Page Node
'	g) @F	Root Field Node

	On Error Resume Next	
  
  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 

  Set DCONav=g_DCSmart.DCONav(sFindNode)	
		

End Function
		
Function DCOFindVar(byVal sFindObjID)
		

    On Error Resume Next
	
    If Not IsAlive(g_DCSmart) then
       Writelog("Datacap Smart Parameter object not found")
	     Exit function
    End if 
    
	  DCOFindVar=g_DCSmart.DCOFindVar(sFindObjID)
   	    

End Function
		
Function DCONavGetValue(byVal sFindObjID)
		
	On Error Resume Next
	  
  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 
  
	DCONavGetValue=g_DCSmart.DCONavGetValue(sFindObjID)
  			

End Function
		
Function DCONavSetValue(byVal sFindObjID,byVal sNewValue)
		
	On Error Resume Next
	
  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 

	DCONavSetValue=g_DCSmart.DCONavSetValue(sFindObjID,sNewValue)
			

End Function
		
Function MetaWord(sArgument)
		
		
    On Error Resume Next

   If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
   End if 
  
   MetaWord=g_DCSmart.MetaWord(sArgument)
	  

End Function
		
Function DCONavType()
		

	On Error Resume Next

  If Not IsAlive(g_DCSmart) then
     Writelog("Datacap Smart Parameter object not found")
	   Exit function
  End if 

  DCONavType=g_DCSmart.DCONavType()
   		

End Function
		
'END DCO NAVIGATION

Function Status_Preserve_ON(bInter, bDebug) 
   
    RRState.OnRuleFailure="Call StatCounter():Call RRLogicOnRuleEnd():Call OnRuleEnd()"
    RRState.OnRuleSuccess="Call StatCounter():Call RRLogicOnRuleEnd():Call OnRuleEnd()"
    RRState.OnRulesetStart="Call OnRuleSetStart()"    

	Status_Preserve_ON = True

End Function

Function Status_Preserve_OFF(bInter, bDebug) 
    RRState.OnRuleStart="Call OnRuleStart():If CurrentObj.Status=nFail then CurrentObj.Status=nPass:CurrentObj.DeleteVariable(""MESSAGE""):nDefaultRtn = nRtn_Over:Call RRLogicSetDefaultRtnForOverride"    
    RRState.OnRuleSuccess="Call StatCounter():Call RRLogicOnRuleEnd():Call OnRuleEnd()"    
    
    'RRState.OnRuleFailure="Call StatCounter():Call OnRuleFailure():Call OnRuleEnd()"
    ' Updates to support RuleRunnerLogic #C DLL
    RRState.OnRuleFailure= "Call StatCounter():Call RRLogicOnRuleFailure():Call RRLogicOnRuleEnd():Call OnRuleEnd()"
                                                     
    RRState.OnRuleSetStart="Call OnRuleSetStart():RRState.OnRuleFailure="""":RRState.OnRuleStart=""Call OnRuleStart()"""
    
  
	Status_Preserve_OFF = True
	Writelog("Initializing Calling Object to status " & nPass)
	CurrentObj.Status = nPass
  CurrentObj.DeleteVariable("MESSAGE")	

End Function

Function DebugMode_ON(bInter, bDebug) 
  bDebug = True
	DebugLog("DebugMode ON")
	DebugMode_ON = True

End Function

Function DebugMode_OFF(bInter, bDebug) 
	Debuglog("DebugMode OFF")
	bDebug = False
	DebugMode_OFF = True

End Function

Function CheckAllIntegrity(bInter, bDebug) 
	Dim LastChecked
	Dim rtn

	CheckAllIntegrity = True
	
	rtn = DCO.CheckIntegrity(LastChecked)
	
	If rtn <> 0 Then
		If Not LastChecked Is Nothing Then
			WriteLog("CheckIntegrity returned : " & rtn & vbCrLf & Space(5) & "ID of last checked: " & LastChecked.ID) 
		End If
		CheckAllIntegrity = False
	End If

End Function

Function CheckDocCount(bInter, bDebug) 
	Dim nD
	Dim nDD
	Dim ED
	Dim aD
	Dim vD		
			
	nD = Trim(Pilot.ExpectedDocs)
	If nD="" or Not(isnumeric(nD)) then nD=0
	
	ED = Trim(DCO.Variable("ED"))
	If ED="" or Not(isnumeric(ED)) then ED=0
		
	If cint(nD)<=cint(1) and cint(ED)>0 then
		Writelog("DCO variable ED value found. Setting Pilot.ExpectedDocs to " & cstr(ED))
		nD = ED		
		Pilot.ExpectedDocs = clng(nD)
	End if

	aD = Trim(Pilot.AdjustedDocs)
	If aD="" or Not(isnumeric(aD)) then aD=0
		
	vD = Trim(DCO.Variable("AD"))
	If vD="" or Not(isnumeric(vD)) then vD=0

	If cint(aD)=cint(0) and cint(vD)>0 then
		Writelog("DCO variable AD value found. Setting Pilot.AdjustedDocs to " & cstr(vD))
		aD = vD		
		Pilot.AdjustedDocs = clng(aD)
	End if

	WriteLog("Expected documents:" & nD & ".")
	If aD>0 then 
		WriteLog("Adjusted documents:" & aD & ".")
		nD=aD
	End if 
	 
	nDD = ObjectCount(DCO, 1)

	WriteLog("Found " & cstr(nDD) & " documents")

	If cint(nDD) <> cint(nD) Then 
		WriteLog("Expected documents count does not match actual documents count!")
		CheckDocCount = False
	Else
		CheckDocCount = True
	End If


End Function

Function CheckPageCount(bInter, bDebug) 
	Dim nP
	Dim nPP
	Dim aP
	Dim vP
		
	nP = Trim(Pilot.ExpectedPages)
	If nP="" or Not(isnumeric(nP)) then nP=0
	
	nP = Trim(DCO.Variable("EP"))
	If nP="" or Not(isnumeric(nP)) then nP=0

	If cint(nP)=cint(0) and Len(EP)>0 then
		Writelog("DCO variable EP value found. Setting Pilot.ExpectedDocs to " & cstr(EP))
		nP = EP
		Pilot.ExpectedPages = clng(nP)
	End if

	aP = Trim(Pilot.AdjustedPages)
	If aP="" or Not(isnumeric(aP)) then aP=0
		
	vP = Trim(DCO.Variable("AP"))
	If vP="" or Not(isnumeric(vP)) then vP=0

	If cint(aP)=cint(0) and Len(vP)>0 then
		Writelog("DCO variable AP value found. Setting Pilot.AdjustedPages to " & cstr(vP))
		aP = vP		
		Pilot.AdjustedPages = clng(aP)
	End if

	WriteLog("Expected Pages:" & nP & ".")
	If aP>0 then 
		WriteLog("Adjusted pages:" & aP & ".")
		nP=aP
	End if 
	 
	nPP = ObjectCount(DCO, 2)

	WriteLog("Found " & cstr(nPP) & " pages")

	If cint(nPP) <> cint(nP) Then 
		WriteLog("Expected pages count does not match actual pages count!")
		CheckPageCount = False
	Else
		CheckPageCount = True
	End If

End Function

Function Task_RaiseCondition(bInter, bDebug, strParam) 
' Strparam is a CSV value
' 1) is the childindex
' 2) is the Condition to set the child to.			
	
	Dim aStrparam
	Dim nChildIndex
	Dim nConditionIndex

	Task_RaiseCondition= False

	aStrParam = Split(strParam & ",",",")
	nChildIndex = aStrParam(0)	
	nConditionIndex = aStrParam(1)

	If Not IsNumeric(nChildIndex) Then Exit Function
	If Not IsNumeric(nConditionIndex) Then Exit Function

	nConditionIndex = CLng(nConditionIndex)
	nChildIndex= CLng(nChildIndex)

	Pilot.ChildCondition(nChildIndex) = nConditionIndex

	Task_RaiseCondition= True

End Function

Function Task_NumberOfSplits(bInter, bDebug, nNumOfSplits) 
	Task_NumberOfSplits= False
	If Not IsNumeric(nNumOfSplits) Then
		Writelog("NumOfSplits Value is not Numeric.")
		Exit Function
	End If
	pilot.ChildrenQuantity=(CLng(nNumOfSplits))
	Writelog("Setting Task Number Of Splits to : " & nNumOfSplits)
	Task_NumberOfSplits= True

End Function

Function SetTaskStatus(bInter, bDebug, StrParam)  
 'use global variable nTaskStatus to send status to RuleRunner
 Const RetAbort = 0
 Const RetFinished = 2
 Const RetPending = 8
 Const RetHold = 4
   if(isNumeric(StrParam)) then
      nTaskStatus = cint(StrParam)
        RRState.Data("nTaskStatus")=StrParam
      Writelog("Set status of task to " & StrParam)
      SetTaskStatus = true
   else
     Writelog("Action's parameter is not numeric")
     SetTaskStatus = false 
   end if

End Function

Function SkipChildren(bInter, bDebug) 
	
    RRState.SkipChildren=True
	SkipChildren = True
	bprocesschildren = False

End Function

Function SetExpectedDocs(bInter, bDebug, StrParam) 
  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrSet.">
  'DEPRICATED use --> rrSet(@B.ED,value)
  
	SetExpectedDocs = False
	
	StrParam = Trim(StrParam)
	
	If Not IsNumeric(StrParam) then 
		Writelog("Value Must be Numeric.")
		Exit Function
	End if
	SetExpectedDocs = True
	DCO.Variable("ED") = StrParam
	Pilot.ExpectedDocs = StrParam
				

End Function

Function SetExpectedPages(bInter, bDebug, StrParam) 
  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrSet.">
  'DEPRICATED use --> rrSet(@B.EP,Value)
  
	SetExpectedPages = False
	
	StrParam = Trim(StrParam)
	
	If Not IsNumeric(StrParam) then 
		Writelog("Value Must be Numeric.")
		Exit Function
	End if
	SetExpectedPages = True
	DCO.Variable("EP") = StrParam
	Pilot.ExpectedPages = StrParam
			

End Function

Function AbortOnError(bInter, bDebug, StrParam) 
	AbortOnError = True

	StrParam = Trim(StrParam)

	Select Case ucase(strparam)
		Case "TRUE"
			Writelog("Setting Task to Abort On Errors")
			g_bAbortOnError = True
		Case "FALSE"
			Writelog("Setting Task to Continue On Errors")
			g_bAbortOnError = False
		Case Else
			AbortOnError = False
			Writelog("Invalid Parameter. Expecting 'True' or 'False', received '" & StrParam & "'.")
	End Select		
	
  
End Function

Function PilotMessage_Set(bInter, bDebug, StrParam) 

  Dim sSmartParam

  sSmartParam = MetaWord(StrParam)
  If len(sSmartParam)="" then 
     Writelog("Smart Parameter parsing did not return a value. Defaulting message to the Action argument.")
     sSmartParam =StrParam
  End if
	CurrentObj.Variable("MESSAGE")= Trim(sSmartParam)	
	PilotMessage_Set=True

End Function

Function PilotMessage_Clear(bInter, bDebug) 
	
	CurrentObj.DeleteVariable("MESSAGE")	
	CurrentObj.DeleteVariable("MessageID")

    'TODO:  somehow CurrentObj.GetVariableName(index) sometimes return empty string and miss the MessageParam variable names, so use for loop for 20 message variables
	For index = 0 To 20
		rc = CurrentObj.DeleteVariable("MessageParamType_"&index)
		if rc = false then
			Exit For
		End if
		rc = CurrentObj.DeleteVariable("MessageParamText_"&index)
		if rc = false then
			Exit For
		End if		
	Next	
	
	PilotMessage_Clear=True

End Function

'BEGIN META ACTION SECTION

Function rrSet(varSource,varTarget)
		
  ' rr_Set was replaced by rrSet so we could use the "f" tag with unique parameters.

  Dim aStrParam
	Dim sSource
	Dim sDestination
	Dim sValue
	
	On Error Resume Next
	
	rrSet = False
		
	sSource = Trim(varSource)
	sDestination = Trim(varTarget)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sDestination) = 0 Then sDestination = DCONavType()

  ' If sSource = sDestination Then we don't care, perform the copy anyway.		
		
	sValue = MetaWord(sSource)    
	rrSet = DCONavSetValue(sDestination,sValue)
	
	Call ErrorHandler("rrSet") 
  
End Function
		
Function rr_Set(bInter, bDebug, StrParam) 

  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrSet."
  'DEPRECATED 8.1.0.81 5.18.2011
  
  Dim aStrParam
	Dim sSource
	Dim sDestination
	Dim sValue
	
	On Error Resume Next
	
	rr_Set = False
		
	aStrParam = Split(StrParam & ",",",")
	sSource = Trim(aStrParam(0))
	sDestination = Trim(aStrParam(1))
  
  rr_Set = rrSet(sSource, sDestination)
	
	Call ErrorHandler("rr_Set") 
		

End Function

Function rrSet_ID(SourceValue,TargetDCO)
		
  
  Dim aStrParam
	Dim sSource
	Dim sDestination
	Dim sValue
	
	On Error Resume Next
	
	rrSet_ID = False
		
	sSource = Trim(SourceValue)
	sDestination = Trim(TargetDCO)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sDestination) = 0 Then sDestination = DCONavType()
		
	sValue = MetaWord(sSource)    
  
  Set oTarget = DCONav(sDestination)
	If Not IsAlive(oTarget) then 
		Writelog("Copy to node not found.")
		rrSet_ID=False
		Exit Function
	End if
  
	oTarget.ID = sValue
	
  If Err=0 then rrSet_ID=True
  
	Call ErrorHandler("rrSet_ID") 
  
End Function
		
Function rr_Get(bInter, bDebug, StrParam) 
	Dim sValue
	Dim sSource
	Dim sDestination
	
	On Error Resume Next
	
	rr_Get = False
		
	sSource = StrParam
		
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sDestination) = 0 Then sDestination = DCONavType()
	
  ' This condition will occur only if no parameter is supplied.
	If sSource = sDestination Then 
		Writelog("A parameter is required for rr_Get(). Exiting Action.")
		Exit Function
	End if
		
	sValue = MetaWord(sSource)
	rr_Get = DCONavSetValue(sDestination, sValue)
	
	Call ErrorHandler("rr_Get") 
		

End Function

Function rrContains(SearchForValue,SearchInValue,caseSensitive)
		
  'Text that the action is looking for in the current field.
  'This action determines if a field represented by the bound object of the 
  'Document Hierarchy contains some or all of the parameter's text value, without additional unspecified text. 

  On Error Resume Next

	rrContains = False
  
  sSearchFor = Trim(SearchForValue)
	sSearchIn = Trim(SearchInValue)
  
  caseSensitive = Trim(caseSensitive)
  If len(caseSensitive) = 0 then caseSensitive="FALSE"
  
	If len(sSearchFor) = 0 Then sSearchFor = DCONavType()
	If len(sSearchIn) = 0 Then sSearchIn = DCONavType()
	
  If sSearchFor = sSearchIn Then 
    Writelog("Search For and Search In reference the same component. Returning True.")
    rrContains = True
    Exit Function
  End if
		
	sValueSearchFor = MetaWord(sSearchFor)
	sValueSearchIn = MetaWord(sSearchIn)
  	
  Writelog("'Checking if: '" & sValueSearchFor & "' is in '" & sValueSearchIn & "'.")    

  if (UCase(caseSensitive) = "FALSE") Then 
     writelog("Case insensitive comparison")
     sValueSearchIn = ucase(sValueSearchIn)
     sValueSearchFor = ucase(sValueSearchFor)
  End if	
    
  If instr(sValueSearchIn, sValueSearchFor)>0 Then
		rrContains = True
	End If
		
  Call ErrorHandler("rrContains") 

End Function
		
Function rrCompareCase(object1,object2,caseSensitive)
		
    
  Dim aStrParam
	Dim sSourceA
	Dim sSourceB
	Dim sValueA
	Dim sValueB
	
	On Error Resume Next
	
	rrCompareCase = False
		
	sSourceA = Trim(object1)
	sSourceB = Trim(object2)
  caseSensitive = Trim(caseSensitive)
	
	If len(sSourceA) = 0 Then sSourceA = DCONavType()
	If len(sSourceB) = 0 Then sSourceB = DCONavType()
	
  If sSourceA = sSourceB Then 
    Writelog("Source A and B reference the same component. Returning True.")
    rrCompareCase = True
    sSourceA = ""
	  sSourceB = ""
    Exit Function
  End if
		
	sValueA = MetaWord(sSourceA)
	sValueB = MetaWord(sSourceB)
	
	Writelog("Case Sensitive = '" & UCase(caseSensitive) & "' Comparing: '" & sValueA & "' = '" & sValueB & "'")
	
  dim compareType  
  compareType = 0
  if (UCase(caseSensitive) = "FALSE") Then 
     writelog("Case insensitive comparison")
     compareType = 1
  End if
  
  If StrComp(sValueA, sValueB, compareType) = 0 Then
    rrCompareCase = True
	End if
  
	'If sValueA = sValueB Then
	'	rrCompare = True
	'End if
	
  sSourceA = ""
	sSourceB = ""
  sValueA = ""
  sValueB = "" 
  
	Call ErrorHandler("rrCompareCase") 
  
End Function
		
Function rrCompare(object1,object2)
		
  ' rr_Compare was replaced by rrCompare so we could use the "f" tag with unique parameters.
	
	On Error Resume Next
	
	rrCompare = rrCompareCase(object1, object2, "TRUE")  
	
	Call ErrorHandler("rrCompare") 
  
End Function
		
Function rr_Compare(bInter, bDebug, StrParam) 
 
  'qi="This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCompare."
  'DEPRECATED 8.1.0.18 5.18.2011 

	Dim aStrParam
	Dim sSourceA
	Dim sSourceB
	Dim sValueA
	Dim sValueB
	
	On Error Resume Next
	
	rr_Compare = False
		
	aStrParam = Split(StrParam & ",",",")
	sSourceA = Trim(aStrParam(0))
	sSourceB = Trim(aStrParam(1))
	
	rr_Compare = rrCompare(sSourceA, sSourceB)
	
	Call ErrorHandler("rr_Compare") 

End Function

Function rrCompareNotCase(object1,object2,caseSensitive)
		
  
  On Error Resume Next
	
	if rrCompareCase(object1, object2, caseSensitive) Then
     rrCompareNotCase = False
  Else
     rrCompareNotCase = True
  End if

	Call ErrorHandler("rrCompareNot") 
  
End Function
		
Function rrCompareNot(object1,object2)
		
  ' rr_Copy was replaced by rrCopy so we could use the "f" tag with unique parameters.
  
  On Error Resume Next
	
	if rrCompare(object1, object2) Then
     rrCompareNot = False
  Else
     rrCompareNot = True
  End if

	Call ErrorHandler("rrCompareNot") 
  
End Function
		
Function rr_Compare_Not(bInter, bDebug, StrParam) 
	On Error Resume Next
	
  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCompareNot"
  'DEPRECATED v8.1.0.18 5.18.2011
  
	if rr_Compare(bInter, bDebug, StrParam) Then
     rr_Compare_Not = False
  Else
     rr_Compare_Not = True
  End if

	Call ErrorHandler("rr_Compare_Not") 

End Function

Function rrCompareCaseLength(object1,object2,caseSensitive,length,fromStart)
		

	On Error Resume Next
  Dim nLen
  
  rrCompareCaseLength = false
	
  if (Not (isNumeric(StrParam))) then
     writelog("length parameter '" & length & "' is not numeric.  Returning false")
     Exit Function   
  end if

  nLen = cint(length)
  
  if (nLen <= 0) Then
     writelog("length parameter is 0.  Comparing entire string.")
     rrCompareCaseLength = rrCompareCase(object1, object2, caseSensitive)  
     Exit Function
  End if
 
  Dim sObj1
  Dim sObj2
 
  sObj1 = MetaWord(object1)
  Writelog("Object1 = " & sObj1)
  sObj2 = MetaWord(object2)
  Writelog("Object2 = " & sObj2)

  if (UCASE(fromStart) = "TRUE") Then
     sObj1 = Left(sObj1, nLen)
     sObj2 = Left(sObj2, nLen)
     writelog("Comparing From Start: '" & sObj1 & "' and '" & sObj2 & "'.")
  else
     sObj1 = Right(sObj1, nLen)
     sObj2 = Right(sObj2, nLen)
     writelog("Comparing From End: '" & sObj1 & "' and '" & sObj2 & "'.")
  End if
  
	rrCompareCaseLength = rrCompareCase(sObj1, sObj2, caseSensitive)  
	
	Call ErrorHandler("rrCompare") 
  
End Function
		
Function rrCompareNotCaseLength(object1,object2,caseSensitive,length,fromStart)
		

	On Error Resume Next

  If (rrCompareCaseLength(object1, object2, caseSensitive, length, fromStart)) Then
     rrCompareNotCaseLength = False
  else
     rrCompareNotCaseLength = True
  End If
	
	Call ErrorHandler("rrCompareNotCaseLength") 
  
End Function
		
Function rrCopy(varSource,varTarget)
		
  ' rr_Copy was replaced by rrCopy so we could use the "f" tag with unique parameters.
    
	Dim sSource
	Dim sTarget
	Dim oSource
	Dim oTarget
	Dim sOrigImageN
	Dim sOrigImageH
	Dim oChild
	Dim nChildren
	
	On Error Resume Next

	rrCopy = True
		
	sSource = Trim(varSource)
	sTarget = Trim(varTarget)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sTarget) = 0 Then sTarget = DCONavType()
	
	If sSource = sTarget Then 
		Writelog("Source and Target are to the same component. Exiting Action.")
		Exit Function
	End if
		
	Set oSource = DCONav(sSource)
	If Not IsAlive(oSource) then 
		Writelog("Copy from node not found.")
		rrCopy=False
		Exit Function
	End if
	
	Set oTarget = DCONav(sTarget)
	If Not IsAlive(oTarget) then 
		Writelog("Copy to node not found.")
		rrCopy=False
		Exit Function
	End if
	
	'Get Target original
		
	'Target original values
	oTarget.Text=""
	oTarget.Variable("Position")="0,0,0,0"
	
	'Check Source has value
	If oSource.Text="" then 
		Writelog("Source field has no value.")
		Exit Function
	End if
	
	Writelog("Copying Node: '" & oSource.ID & "' value:'" & oSource.Text & "' image:'" & oSource.Variable("IMAGEFILE") & "' to '" & oTarget.ID & "'")
	
	Call RRCopyChars(oSource,oTarget,1,len(oSource.Text))
	Call RRCopyPos(oSource,oTarget,1,len(oSource.Text))
	Call RRCopyImage(oSource,oTarget)
		
	Writelog("New Target Value:'" & oTarget.Text & "'  Position:'" & oTarget.Variable("Position") & "' image:'" & oTarget.Variable("IMAGEFILE") & "'")		
				
	Call ErrorHandler("rrCopy")   
  
End Function
		
Function rr_Copy(bInter, bDebug, StrParam) 

  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCopy."
  'DEPRECATED v8.1.0.18 5.18.2011
  
	Dim aStrParam
	Dim sSource
	Dim sTarget
	
	On Error Resume Next
		
	aStrParam = Split(StrParam & ",",",")
	sSource = Trim(aStrParam(0))
	sTarget = Trim(aStrParam(1))

  rr_Copy = rrCopy(sSource, sTarget)
				
	Call ErrorHandler("rr_Copy") 		

End Function

Function rrAppend(varSource,varTarget)
		
  ' rr_Append was replaced by rrAppend so we could use the "f" tag with unique parameters.
  Dim sSource
  Dim sTarget
  Dim oSource
  Dim oTarget
  Dim sOrigImageN
  Dim sOrigImageH
  Dim oChild
  Dim nChildren
  Dim oChar
  Dim i

	On Error Resume Next

	rrAppend = True
		
	sSource = Trim(varSource)
	sTarget = Trim(varTarget)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sTarget) = 0 Then sTarget = DCONavType()
	
	If sSource = sTarget Then 
		Writelog("Source and Target are to the same component. Exiting Action.")
		Exit Function
	End if
		
	sValue = MetaWord(sSource)
	If Len(sValue)=0 then 
		Writelog("Source argument or object does not have a value. Exiting.")
		rrAppend=False
		Exit Function
	End if
	
	Set oTarget = DCONav(sTarget)
	If Not IsAlive(oTarget) then 
		Writelog("Append to node not found.")
		rrAppend=False
		Exit Function
	End if
		
  Writelog("Start Value of Target:'" & oTarget.Text & "'")

	For i = 1 to Len(sValue)
		Set oChar = oTarget.AddChild(4,"",-1)
		
		If Not oChar is Nothing then 
					
			oChar.CharValue(0)= Clng(ASCW(Mid(sValue,i,1)))
			oChar.CharConfidence(0) = Clng(9)
			bRes = oChar.SetPosition(clng(0),clng(0),clng(0),clng(0))
				
		End if
	Next 'x

	Set oChar = Nothing
			
  Writelog("End Value of Target:'" & oTarget.Text & "'")
  
	Call ErrorHandler("rrAppend")   
  
End Function
		
Function rr_Append(bInter, bDebug, StrParam) 

  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrAppend."
  'DEPRECATED v8.1.0.18 5.18.2011
  
  Dim aStrParam
  Dim sSource
  Dim sTarget

	On Error Resume Next

	aStrParam = Split(StrParam & ",",",")
	sSource = Trim(aStrParam(0))
	sTarget = Trim(aStrParam(1))

  rr_Append = rrAppend(sSource, sTarget)

	Call ErrorHandler("rr_Append") 

End Function

Function rrPrepend(varSource,varTarget)
		
  ' rr_Append was replaced by rrAppend so we could use the "f" tag with unique parameters.  
	Dim sSource
	Dim sTarget
	Dim oSource
	Dim oTarget
	Dim sOrigImageN
	Dim sOrigImageH
	Dim oChild
	Dim nChildren
	Dim oChar
  Dim i

	On Error Resume Next

	rrPrepend = True
		
	sSource = Trim(varSource)
	sTarget = Trim(varTarget)
	
	If len(sSource) = 0 Then sSource = DCONavType()
	If len(sTarget) = 0 Then sTarget = DCONavType()
	
	If sSource = sTarget Then 
		Writelog("Source and Target are to the same component. Exiting Action.")
		Exit Function
	End if
		
	sValue = MetaWord(sSource)
	If Len(sValue)=0 then 
		Writelog("Source argument or object does not have a value. Exiting.")
		rrPrepend=False
		Exit Function
	End if
	
	Set oTarget = DCONav(sTarget)
	If Not IsAlive(oTarget) then 
		Writelog("Append to node not found.")
		rrPrepend=False
		Exit Function
	End if
		
  Writelog("Start Value of Target:'" & oTarget.Text & "'")

	For i = 1 to Len(sValue)
		Set oChar = oTarget.AddChild(4,"",i-1)
		
		If Not oChar is Nothing then 
					
			oChar.CharValue(0)= Clng(ASCW(Mid(sValue,i,1)))
			oChar.CharConfidence(0) = Clng(9)
			bRes = oChar.SetPosition(clng(0),clng(0),clng(0),clng(0))
				
		End if
	Next 'x

	Set oChar = Nothing
			
  Writelog("End Value of Target:'" & oTarget.Text & "'")

	Call ErrorHandler("rrPrepend") 
  
End Function
		
Function rr_Prepend(bInter, bDebug, StrParam) 
  
  'This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrPreped."
  'DEPRECATED v8.1.0.18 5.18.2011
  
  Dim aStrParam
	Dim sSource
	Dim sTarget

	On Error Resume Next

	aStrParam = Split(StrParam & ",",",")
	sSource = Trim(aStrParam(0))
	sTarget = Trim(aStrParam(1))

	rr_Prepend = rrPrepend(sSource, sTarget)

	Call ErrorHandler("rr_Prepend") 

End Function

'END META ACTION SECTION

Function rr_WriteNode(bInter, bDebug) 
		
	Dim sNodeFileName	
	
	On Error Resume Next 
	
	rr_WriteNode=True
	
	sNodeFileName=Pilot.BatchDir & "\" & CurrentObj.ID & ".xml"
		
	CurrentObj.Variable("DATAFILE")=sNodeFileName
		

End Function

Function rr_AbortBatch(bInter, bDebug) 
  	rr_AbortBatch = False
    
    Call AbortBatch()  


End Function

Sub AbortBatch() 
  ' Sets the Batch to Abort
  
    Writelog("Setting Batch to stop processing rules and end with status ABORTED.")
    
    bAbort = True
    nTaskStatus = RetAbort 
      RRState.Data("bAbort")="True"
      RRState.LogicResult=-1  


End Sub

Function GotoNextRule(bInter, bDebug) 
  '"This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by GoToNextFunction."
	'This action has been deprecated. It has been replaced by "GoToNextFunction".
	GoToNextRule = False
	GoToNextRule = GoToNextFunction()

End Function

Function GoToNextFunction()
		
	GoToNextFunction = False
	WriteLog("GoToNextFunction returning " & GoToNextFunction & " so next function in the RuleSet will run.") 
	'Call ErrorHandler("Function GoToNextFunction") 

End Function
		
Function SetReturnValue(bInter, bDebug, StrParam) 
	on error resume next
  
  SetReturnValue = False
  
  StrParam = Trim(StrParam)  
  if (ucase(StrParam) = "TRUE") then
    SetReturnValue = True
  end if      
  Writelog("SetReturnValue returns: " & SetReturnValue)
  
End Function

Function SetIsOverrideable(bInter, bDebug, StrParam) 
   '  Specifies that if the validation fails for the current object, If it is non-overrideable 
   '  or overrideable by the user.
   '  This status may prevent an operator from overriding a field's validations 
   '  and then continuing to subsequent pages. 
   
   ' IMPORTANT! - THIS IS A DUPLICATE NAMED METHOD WHICH ALSO EXISTS IN VALIDATIONS.  Which one is called is determined by the load order, 
  ' It doesn't matter which one is called out in Datacap Studio.  THIS IS A VB LIMITATION and why we should NEVER have duplicate named VB actions.
  ' BOTH THE Validation and rrunner versions MUST be kept identical.
   
   'Added support for smart parameters
   StrParam=MetaWord(StrParam)
   writelog("Param: '" & StrParam & "'")
   
   Set oBatch = CurrentObj    ' Find the batch node - Even though we are likely on a field, RuleRunnerLogic will check the batch node after at the end of the rules.
   While oBatch.ObjectType > 0
       Set oBatch = oBatch.Parent    
   Wend
   
   WriteLog("SetIsOverrideable parameter is " & StrParam)
   If Ucase(StrParam) = Ucase("True") Then
      nDefaultRtn = nRtn_Over
      oBatch.Variable("nDefaultRtn")="1" ' 1 = can override - This is for compatability with RuleRunnerLogic which needs to use the DCO variable.
      WriteLog("rr Setting Rule to Overrideable.")
   Else
      nDefaultRtn = nRtn_Fail
      oBatch.Variable("nDefaultRtn")="2" ' 2 = cannot override - This is for compatability with RuleRunnerLogic which needs to use the DCO variable.
      WriteLog("rr Setting Rule to NON Overrideable.")
   End If
   SetIsOverrideable = True
	

End Function

Function ProcessChildren(bInter, bDebug, StrParam) 
	Dim aStrParam

  On Error Resume Next

  ProcessChildren = FALSE

  aStrParam = Split(StrParam,",")

  If uBound(aStrParam) <> 1 then
    Writelog("Expecting comma separated arguments (Condition,Command). Wrong number of parameters. Exiting")
    Exit Function
  End if

  Call u_RecurseObject(CurrentObj,aStrParam(0),aStrParam(1),cint(0))

  ProcessChildren = TRUE
  

End Function

Function u_RecurseObject(Obj,Condition,Command,Indent)
		
' utility function for ProcessChildren Action

	Dim i
  Dim NextIndent
  Dim nChildren
  
  On Error Resume Next
  
  Writelog(space(Indent) & "-- ProcessChild '" & Obj.ID & "'")

  If Eval(Condition) then
    Writelog(space(Indent) & "   * Condition Found: " & Condition)
    Writelog(space(Indent)& "   * Executing Command: " & Command)
    Execute(Command)
  End if

  If Err.Number<>0 then Exit function

  NextIndent = Indent + cint(3)

  'Count of child objects -  character obj count
  nChildren = Obj.NumOfChildren - len(Obj.Text)

  For i = 1 to nChildren
    Call u_RecurseObject(Obj.GetChild(i-1),Condition,Command,NextIndent)
  Next 'i


End Function
		
Function SetBatchPriority(Priority)
		
' Sets the Batch priority for the current Batch
   
  On Error Resume Next
  
  Dim SmartVal
  
  SetBatchPriority=False
  
  SmartVal=MetaWord(Priority)
  If Len(SmartVal)>0 then Priority=SmartVal
  
  If Not Isnumeric(Priority) Then 
    Writelog("Parameter must be numeric.")
    Exit Function
  End if
  
  Priority=cInt(Priority)
  
  If Priority<0 Then 
    Writelog("Parameter must be a non negative integer.")
    Exit Function
  End if
  
  Pilot.Priority=Priority 
  
  If Err.Number=0 then
    SetBatchPriority=True
    Writelog("Batch Priority set to '" & cStr(Priority) & "'")
  End if
 

End Function
		
Function SetOperatorID(OperatorID)
		
' Sets the Batch OperatorID for the current Batch
   
  On Error Resume Next
  
  Dim sSmartVal
  
  SetOperatorID=False
      
  SmartVal=MetaWord(OperatorID)
  If Len(SmartVal)>0 then OperatorID=SmartVal
    
  Pilot.Operator=cstr(OperatorID) 
  
  If Err.Number=0 then
    SetOperatorID=True
    Writelog("Operator set to '" & OperatorID & "'")
  End if
 

End Function
		
Function SetStationID(StationID)
		
' Sets the Batch StationID for the current Batch
   
  On Error Resume Next
  
  Dim sSmartVal
  
  SetStationID=False
      
  SmartVal=MetaWord(StationID)
  If Len(SmartVal)>0 then StationID=SmartVal
  
  Pilot.Station=cStr(StationID) 
  
  If Err.Number=0 then
    SetStationID=True
    Writelog("Station set to '" & StationID & "'")
  End if
 

End Function
		
Function rrCompareNumeric(object1,operator,object2)
		
      
      Dim sSourceA
	  Dim sSourceB
      Dim sSourceOperator
      Dim sValueA
      Dim sValueB
      Dim lValueA
      Dim lValueB
      
      'Can be extend to other logical operators like <>, <= or >= if needed in future
      Dim sValidOperators 
      sValidOperators= "<,>,="
      
      Writelog("Calling rrCompareNumeric....")
      On Error Resume Next
            	
	    rrCompareNumeric = False
  
      sSourceA = Trim(object1)
    	sSourceB = Trim(object2)
      sSourceOperator=Trim(operator)
      
       
      	If len(sSourceA) = 0 Then sSourceA = DCONavType()
	      If len(sSourceB) = 0 Then sSourceB = DCONavType()
        
        'if operator is blank then returns false.
        If len(sSourceOperator) = 0 Then 
          Writelog("Logical operator is a mandatory parameter. Returning false")
          rrCompareNumeric = False   
          Exit Function
        End if
        
        sValueA = MetaWord(sSourceA)
        sValueB = MetaWord(sSourceB)
        
        Writelog("Object 1: "+sValueA + " Object 2: "+sValueB+" Operator: "+sSourceOperator)
     
         'Check for numeric values if passed
         If Not (IsNumeric(sValueA) and IsNumeric(sValueB)) Then
           Writelog("Parameters used for comparison should be numeric. Returning false")
           Exit Function
         End if
         
         'Check if correct operator passed, verify from the list of valid operators
         If Not ( (InStr(sValidOperators,sSourceOperator) > 0)) Then
          Writelog(" Operator: "+ sSourceOperator +" is not valid operator. Allowed operators are <, > , = only. Returning false")
          Exit Function
         End if
     
     lValueA=CDbl(sValueA)
     lValueB=CDbl(sValueB)
      
        Writelog("Checking condition...   " + lValueA + " "+sSourceOperator+" "+lValueB)
          
        Select case sSourceOperator
            case "="
                If lValueA = lValueB Then 
                      Writelog("Source A and B reference the same component. Returning True.")
                      rrCompareNumeric = True                
                  Else
                      Writelog("Source A and B reference the different component. Returning False.")
                      rrCompareNumeric = False               
                 End if
                 Exit Function
           case ">"
                 If lValueA > lValueB Then 
                    Writelog("Source A is greater than Source B. Returning True.")
                    rrCompareNumeric = True               
                Else
                    Writelog("Source A is not greater than Source B. Returning False.")
                    rrCompareNumeric = False                
                 End if
                 Exit Function
           case "<"
                 If lValueA < lValueB Then 
                      Writelog("Source A is smaller than Source B. Returning True.")
                      rrCompareNumeric = True                
                  Else
                      Writelog("Source A is not smaller than Source B. Returning False.")
                      rrCompareNumeric = False                  
                 End if
                 Exit Function
           case else
                 Writelog("Incorrect operator. Returning false")
                 rrCompareNumeric = False         
                 Exit Function
      End Select                  
      
      Call ErrorHandler("rrCompareNumeric")       
      
End Function
		
function tm_GetMyGroups()
	tm_GetMyGroups = RRState.Data("rrs:atm:me:groups")
end function

function tm_GetGroupParam(group, params)
	tm_GetGroupParam = "<!notfound!>" '-2 = no param
	lgroup = MetaWord(group)
	lgroups = tm_GetMyGroups()
	a=Split(lgroups,"|")
	ap=Split(params,"|")
	if LBound(a) <> LBound(ap) or UBound(a) <> UBound(ap) then
		exit function
	end if
	index = -1
	found = false
	for each g in a
		index = index + 1
		if 0 = StrComp(g,lgroup,1) then
			found = true
			exit for
		end if
	next
	if found and -1 < index then
		tm_GetGroupParam = ap(index)
	end if
end function

function tm_GetGroupIndex(group)
	tm_GetGroupIndex = -2 '-2 = no group
	res = tm_GetGroupParam(group, RRState.Data("rrs:atm:me:group_indexes"))
	if res = "<!notfound!>" then
		exit function
	end if	
	tm_GetGroupIndex = CLng(res)
end function

function tm_GetGroupKey(group)
	tm_GetGroupKey = -1
	res = tm_GetGroupParam(group, RRState.Data("rrs:atm:me:group_keys"))
	if res = "<!notfound!>" then
		exit function
	end if	
	tm_GetGroupKey = CLng(res)
end function

function tm_GetGroupWeight(group)
	tm_GetGroupWeight = -1
	res = tm_GetGroupParam(group, RRState.Data("rrs:atm:me:group_weights"))
	if res = "<!notfound!>" then
		exit function
	end if	
	tm_GetGroupWeight = CLng(res)
end function

Function rrIsValidTMGroup(GroupName)
		
	On Error Resume Next
	rrIsValidTMGroup = false
	lgroup = MetaWord(GroupName)
	lgroups = tm_GetMyGroups()
	a=Split(lgroups,"|")
	for each g in a
		if 0 = StrComp(g,lgroup,1) then
			rrIsValidTMGroup = true
			exit for
		end if
	next
	if false = rrIsValidTMGroup then
		call WriteLog("rrIsValidTMGroup: group " & lgroup & " is NOT valid")
	else
		call WriteLog("rrIsValidTMGroup: group " & lgroup & " is valid")
	end if
    
End Function
		
Function rrAddTMGroup2Batch(GroupName,IgnoreFailure)
		
	On Error Resume Next
	lgroup = MetaWord(GroupName)
	rrAddTMGroup2Batch = false
	if IgnoreFailure = false and not rrIsValidTMGroup(GroupName) then
		call WriteLog("error: invalid group " & lgroup)
		exit function
	end if 
	grkey = tm_GetGroupKey(GroupName)
	if -1 < grkey then
		toset = RRState.Data("rrs:atm:batch:bp_key_str")
		toset = toset & "|" & CStr(grkey)
		RRState.Data("rrs:atm:batch:bp_key_str") = toset
		call WriteLog("added " & lgroup & " group to batch; batch is assigned to these group keys: " & toset)
		rrAddTMGroup2Batch = true
	else
		call WriteLog("error: couldn't get key for group " & lgroup)
		rrAddTMGroup2Batch = IgnoreFailure
	end if
    
End Function
		
Function rr_eTimer(start_Timer)
		
    
    sTime=cdbl(0) 
    
    Dim end_Timer
    end_Timer = cdbl(Timer)
    
    sTime = end_Timer-cdbl(start_Timer)
    
    if sTime<0 then 
      sTime=sTime-cdbl(86400)
    End if
    
    rr_eTimer=sTime
    
    
End Function
		'namespace ()
                'include (rrunner)

'************************************************************************
' FileNetP8.rrx - FileNet P8 Actions
'
' Licensed Materials - Property of IBM
' Restricted Materials of IBM
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2019 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'------------------------------------------------------------------------
' LOG VERSION:
'Note: 9.1.8.86 populated via RRX.cs
Writelog("FileNetP8 version 9.1.8.86")
'********************************************************************

'Global entries ---------------------------------------------------->
Dim gFileNetP8
Dim g_aPageList()
ReDim g_aPageList(0)
Dim customMimeTypes
Set customMimeTypes = CreateObject("Scripting.Dictionary")


Function InitP8GlobalObjects()
		
	On Error Resume Next
	Err.Clear
	Set gFileNetP8 = new CFileNetP8
	If Err.number <> 0 Then 
		WriteLog( "Couldn't create DC_P8 FileNet object." )
		Str = "ERROR!!! N" + CStr(Err.Number) + vbCrLf _
			+ "Error description = " + Err.Description + vbCrLf _
			+ "Error Source = " + Err.Source
		WriteLog(Str)
	Else
		WriteLog( "DC_P8 FileNet object is loaded OK." )
	End If 
	Err.Clear
	InitP8GlobalObjects = True

End Function
		

InitP8GlobalObjects()

'------------------------------------------------------
'	CFileNetP8
'------------------------------------------------------

Class CFileNetP8
	
	Public  m_oP8Server			'DC P8 Server object
	Public  m_oUploaded			'\P8_Uploaded.xml
	Public  m_FileType 			'type of the uploading files,  ".tif" by default
	Private m_BatchLevel			'bool, prevent from search for Batch level Image from every page
  Public m_CreateMultiPageDoc 'flag multi page doc with Multiple Content Elements (else each page is a doc)
	Public m_DCOVariable			'DCO Variable that defines files to be uploaded to P8
	Public m_Retry				'Amount of retries to upload  
  Public m_pageCount    ' track page # uploading within multipage doc
  Public m_sensitiveContent  ' sensitive info tracked for the current doc
  Public m_sensitiveScan  ' some redaction was scanned for

	'Construction & Destruction 
	Private Sub Class_Initialize		' Initialize event.
		Set m_oUploaded = new C_UploadedXML_P8
		Set m_oP8Server = CreateObject("DC_P8_Server.InterfaceImplementation")
    Set m_oP8Server.DatacapRRLog = DCLogX
		m_FileType = ".tif"
		m_BatchLevel = True
		m_DCOVariable = ""
		m_Retry = 0
    m_CreateMultiPageDoc = False
    m_pageCount = 0
    m_sensitiveContent = False
    m_sensitiveScan = False
	End Sub
	
	Private Sub Class_Terminate		' Terminate event.
		Set m_oUploaded = Nothing
		Set m_oP8Server = Nothing
	End Sub

	'Public methods ------------------------------------------------------
  
  Public Function StartNewDoc
    m_pageCount = 0
    m_sensitiveContent = False
    m_sensitiveScan = False
  End Function
  
  ' CreateDocUsingDCO is recursive, used only if m_CreateMultiPageDoc=True (for exporting multipage 
  ' documents to P8 as multiple content elements)
  Public Function CreateDocUsingDCO(obj)
	  Dim DocImage
    Dim BatchDir
    Dim sDFile
    Dim sBFile 
	  Dim sImage
	  Dim sMFile	' name of file uploaded based on variable name
	  Dim sTmp  
    Dim Lie, nLie   
    
    CreateDocUsingDCO = True		
  
    WriteLog("CreateDocDCO")

	  If Err.Number <> 0 Then
		  CreateDocUsingDCO = False
		  Exit Function
	  End If
		       
    If Not m_DCOVariable="" Then	' if SetUploadMode is not blank, look in variables to find file to upload
	    If (obj.ObjectType = DCO_PAGE) Then
		    Dim strFile, id
		    sMFile = Pilot.BatchDir & "\"
		    sTmp = obj.Variable(m_DCOVariable)
        WriteLog("CreateDocDCO Page sMFile = " & sMFile)
        WriteLog("CreateDocDCO Page sTmp = " & sTmp)
		    
        if Len(sTmp)=0 Then
			    WriteLog("FNP8_Upload action: DCO variable:'" &m_DCOVariable&"' missing or blank, nothing to upload for " & obj.ID)
		    Else			
			    Dim LastIndex
          WriteLog("CreateDocDCO sTmp = " & sTmp)
			    LastIndex = InStrRev(sTmp,":")
			    If LastIndex < 1 Then
				    LastIndex = InStrRev(sTmp,"\\")
				    If LastIndex < 1 Then
					    sMFile = sMFile & sTmp
				    Else
					    sMFile = sTmp'Full path stored in variable
				    End If
			    Else
				    sMFile = sTmp'Full path stored in variable
			    End If
			    WriteLog("CreateDocDCO - Uploading " & sMFile)
			    If m_oUploaded.IsFileUploaded(sMFile) Then
				    Exit Function ' skip if already uploaded
			    End If
		
          WriteLog("CreateDocDCO - AddFile " & sMFile)
          m_oP8Server.AddFile(sMFile)
            m_pageCount = m_pageCount + 1
         
          if IsRedactFileType(sImage) Then
          ' NSK: For each uploaded file (page), if it is a file type that can contain redactions...
          ' NSK: Send redactions on this image to server to create annotations- TBD PAGE NUMBER
		        WriteLog("Check for annotations page " & CStr(m_pageCount))
		        GetAnnotation obj,m_pageCount,sImage
	        End If
      
          CreateDocUsingDCO = True
			    Exit Function
   	    End If	' end Len(sTmp) <> 0				
	    End If ' end DCO_PAGE
	
	    If ((sMFile = "") And (obj.ObjectType < DCO_PAGE)) Then
		    ' we didn't find any file of the requested type at this level, recurse down a level
        WriteLog("CreateDocDCO - we didn't find any file of the requested type at this level, recurse down a level")
		    For i = 0 To obj.NumofChildren-1
			    Set tmpObj = obj.GetChild(i)
			    WriteLog("CreateDocDCO FNP8 upload recurse to " & tmpObj.ID)
			    If (tmpObj.ObjectType < DCO_FIELD) Then CreateDocUsingDCO(tmpObj)
		    Next
	    End If

	    Exit Function	'UploadMode was not blank
    End If ' UploadMode 

	  ' we arrive here only if UploadMode is blank
                
    on error resume next 'needed for uploading to "Unfiled Documents" folder only
  	'Search for Batch or Document level file from lower levels
	  Set DocImage = CurrentObj 'Needed for search for Documnet level image file
    If (CurrentObj.ObjectType > DCO_DOCUMENT) Then
    	Set DocImage = GetDocument(CurrentObj) 'searches for Document level object as a parent for current object
    End If
    sDFile = Pilot.BatchDir & "\" & DocImage.ID & m_FileType        
    
    If Not FileMgr.FileExists(sDFile) Then 	 'There is no Image on Doc level
	    'Writelog("Document level image '" & sDFile & "' is not found, will search for Batch level image.")	
	    If m_BatchLevel=True Then
		    sBFile = Pilot.BatchDir & "\" & Pilot.BATCHID & m_FileType                                              
		    If Not FileMgr.FileExists(sBFile) Then       
			    'There is no Image on Doc and Batch Level
			    'Writelog("Batch level iamge '" & sBFile & "' is not found, uploading image by image.")	
			    m_BatchLevel=False 'No Batch Level image, no need to check every time
		    Else
  			  WriteLog("Uploading Batch Level file " & sBFile)
			    m_oP8Server.AddFile(sBFile)
          ' Redactions not supported yet for multipage image files. When needed, will need to know which pages were included and search redactions page by page.
          CreateDocUsingDCO = True
			    Exit Function										
		    End If ' FileExists(sBFile)
  	  End If ' Batch Level
    Else  ' FileExists(sDFile)
	    WriteLog("Uploading Document Level file " & sDFile)
      m_oP8Server.AddFile(sDFile)
      ' Redactions not supported yet for multipage image files. When needed, will need to know which pages were included and search redactions page by page.      
     m_pageCount = 0
     WriteLog("CreateDocUsingDCO Process CurrentObj.ID = " & CurrentObj.ID)       
     For i = 0 To CurrentObj.NumofChildren-1
        Set tmpObj = CurrentObj.GetChild(i)
        WriteLog("CreateDocDCO  iterate to " & tmpObj.ID)
        If (tmpObj.ObjectType = DCO_PAGE) Then             
            sImage = tmpObj.ImageName
             WriteLog("CreateDocUsingDCO Process CurrentObj.ID = " & CurrentObj.ID) 
             WriteLog("CreateDocDCO: sImage= " & sImage)
            if IsRedactFileType(sImage) Then      
                m_pageCount = m_pageCount + 1		            
		            GetAnnotation tmpObj,m_pageCount,sImage
	           End If        
        End If
     Next
     WriteLog("CreateDocUsingDCO, check for annotations, multipage image files, Done...")
     
      
      CreateDocUsingDCO = True
	    Exit Function				
    End If

   
    ' if we reach here, we are left with looking for document at page level
    
    sImage = obj.ImageName 
    If (obj.ObjectType = DCO_PAGE) Then
	    WriteLog("CreateDocDCO Uploading sImage " & sImage)
      m_oP8Server.AddFile(sImage)
      m_pageCount = m_pageCount + 1
      if IsRedactFileType(sImage) Then
      ' NSK: For each uploaded file (page), if it is a file type that can contain redactions...
      ' NSK: Send redactions on this image to server to create annotations- TBD PAGE NUMBER
		    WriteLog("Check for annotations page" & CStr(m_pageCount))
		    GetAnnotation obj,m_pageCount,sImage
	    End If
      
      if(gFileNetP8.m_CreateMultiPageDoc = True) Then
        nLie = ubound(g_aPageList)
        WriteLog("CreateDocDCO ubound g_aPageList nLie = " & nLie)
	      Redim Preserve g_aPageList(nLie + 1)
        g_aPageList(nLie) = sImage
        nLie = ubound(g_aPageList)
        WriteLog("CreateDocDCO ubound second check g_aPageList nLie = " & nLie)
      End If
      WriteLog("CreateDocDCO done AddFile sImage " & sImage)
      CreateDocUsingDCO = True
	    Exit Function
    End If
	
    If ((sImage = "") And (obj.ObjectType < DCO_PAGE)) Then
	    For i = 0 To obj.NumofChildren-1
		    Set tmpObj = obj.GetChild(i)
		    If (tmpObj.ObjectType < DCO_FIELD) Then 
			    CreateDocUsingDCO(tmpObj)      
		    End If
	    Next  
    End If
  End Function

' UploadDCO is called after the 
' called from FNP8_Upload for single page, via CreateDocUsingDCO for multi-page
  
  Public Function UploadDCO(obj) 
	  Dim DocImage
    Dim BatchDir
    Dim sDFile
    Dim sBFile 
	  Dim sImage
	  Dim sMFile	' name of file uploaded based on variable name
	  Dim sTmp
    
    UploadDCO = True		

	  If Err.Number <> 0 Then
		  UploadDCO = False
		  Exit Function
	  End If
		
    If Not m_DCOVariable="" Then	' if SetUploadMode is not blank, look in variables to find file to upload
	    If (obj.ObjectType = DCO_PAGE) Then
			
		Dim strFile, id
		sMFile = Pilot.BatchDir & "\"
		
		sTmp = obj.Variable(m_DCOVariable)
		
		if Len(sTmp)=0 Then
'			bAbort = True
'			nTaskStatus = RetAbort 	
			WriteLog("FNP8_Upload action: DCO variable:'" &m_DCOVariable&"' missing or blank, nothing to upload for " & obj.ID)
'			Exit Function
		Else			
			Dim LastIndex
			
			LastIndex = InStrRev(sTmp,":")
			If LastIndex < 1 Then
				LastIndex = InStrRev(sTmp,"\\")
				If LastIndex < 1 Then
					sMFile = sMFile & sTmp
				Else
					sMFile = sTmp'Full path stored in variable
				End If
			Else
				sMFile = sTmp'Full path stored in variable
			End If

			WriteLog("Uploading " & sMFile)
			If m_oUploaded.IsFileUploaded(sMFile) Then
				Exit Function
			End If
		
			UploadDCO = UploadFile(sMFile,obj,1) ' hardcoded page number = 1
			Exit Function
        	End If					
	End If
	
	If ((sMFile = "") And (obj.ObjectType < DCO_PAGE)) Then
		' we didn't find any file of the requested type at this level, recurse down a level
		For i = 0 To obj.NumofChildren-1
			Set tmpObj = obj.GetChild(i)
			WriteLog("FNP8 upload recurse to " & tmpObj.ID)
			If (tmpObj.ObjectType < DCO_FIELD) Then UploadDCO(tmpObj)
		Next
	End If

	Exit Function	'UploadMode was not blank
									
    End If ' UploadMode >

	' we arrive here only if UploadMode is blank
                
    on error resume next 'needed for uploading to "Unfiled Documents" folder only

	'Search for Batch or Document level file from lower levels
		
	Set DocImage = CurrentObj 'Needed for search for Documnet level image file
      
    If (CurrentObj.ObjectType > DCO_DOCUMENT) Then

	Set DocImage = GetDocument(CurrentObj) 'searches for Document level object as a parent for current object
    End If
		
    sDFile = Pilot.BatchDir & "\" & DocImage.ID & m_FileType                                              
			        
    If Not FileMgr.FileExists(sDFile) Then 	 'There is no Image on Doc level
	    'Writelog("Document level image '" & sDFile & "' is not found, will search for Batch level image.")	
        
	If m_BatchLevel=True Then
		sBFile = Pilot.BatchDir & "\" & Pilot.BATCHID & m_FileType                                              
		If Not FileMgr.FileExists(sBFile) Then       
			'There is no Image on Doc and Batch Level
			'Writelog("Batch level iamge '" & sBFile & "' is not found, uploading image by image.")	
			m_BatchLevel=False 'No Batch Level image, no need to check every time
		Else
  			WriteLog("Uploading Batch Level file " & sBFile)
			UploadDCO = UploadFile(sBFile,obj,1)
			Exit Function										
		End If
	End If		
    Else

	WriteLog("Uploading Document Level file " & sDFile)
	UploadDCO = UploadFile(sDFile,obj,1)
	Exit Function				
    End If

    sImage = obj.ImageName
    If (obj.ObjectType = DCO_PAGE) Then
	WriteLog("UploadDCO Uploading sImage " & sImage)
	UploadDCO = UploadFile(sImage,obj,1)
	
	Exit Function
    End If
	
    If ((sImage = "") And (obj.ObjectType < DCO_PAGE)) Then
	For i = 0 To obj.NumofChildren-1
		Set tmpObj = obj.GetChild(i)
		If (tmpObj.ObjectType < DCO_FIELD) Then 
			UploadDCO(tmpObj)
		End If
	Next
    End If
End Function

' UploadFile calls server.Upload to upload one file and then the redaction info if any
' only called for single page doc

Public Function UploadFile(sFile,obj,pageNumber)
 'pageNumber now 1-based
	on Error Resume Next
	If m_oUploaded.IsFileUploaded( sFile ) Then 
		UploadFile = True
		Exit Function
	End If
      
	m_FileType=CheckFileType(sFile)
  WriteLog("File Type: " + m_FileType)
  if IsRedactFileType(sFile) Then
		WriteLog("Check for annotations")
		GetAnnotation obj,pageNumber,sFile		
	End If
	strId = m_oP8Server.Upload(sFile)	
			
	If Err.Number <> 0 Then  'We are going to perform retry if can		
		Writelog("Upload failed.")
		Dim Str			
		Str= "ERROR!!! N" + CStr(Err.Number) + vbCrLf _
			+ "Error description = " + Err.Description + vbCrLf _
			+ "Error Source = " + Err.Source

		WriteLog(Str)
    ClearError() 'Needed to clear the 'invalid OIID' error
		If Err.Number <> 0 Then
			Do Until I=CInt(m_Retry)
				Err.Clear
	                	Writelog("Retrying upload. Attempt # "&I+1&" of " & m_Retry & ".")
				strId = m_oP8Server.Upload(sFile)
				If Err.Number <> 0 Then  
					Writelog("Upload failed.")				
					Str= "ERROR!!! N" + CStr(Err.Number) + vbCrLf _
						+ "Error description = " + Err.Description + vbCrLf _
						+ "Error Source = " + Err.Source
			
					WriteLog(Str)			
					If (m_Retry>I+1) Then 'Clear error only when another attempt will follow								
						Err.Clear
					Else
						Exit Do
					End If
				Else 'Upload succedded and if we do have strID lets exit.
					If (strId <> "") Then	
						Exit Do
					Else
						Writelog("Upload failed: the results do not contain a document ID...")				
					End If				
				End If				
		
				I=I+1
			Loop 
		End If
	End If

	If Err.number<>0 Then			
		ErrorHandler()
		UploadFile = False
		Exit Function
	End If

	If (strId = "") Then

		Err.Raise 1,"FileNetP8.rrx","Upload failed: the results do not contain a document ID..."
		UploadFile = False
		Exit Function

	Else

		
		strfile = obj.Variable("FILEUPLOADED")
		If (1>Len(strFile)) Then
			obj.Variable("FILEUPLOADED") = sFile
			obj.Variable("Doc_ID") = strId		
		Else
			strFile = obj.Variable("FILEUPLOADED")
			strFile = strFile & "|" & sFile
			id = obj.Variable("Doc_ID")
			id = id & "|" & strId
			obj.Variable("FILEUPLOADED") = strFile
			obj.Variable("Doc_ID")= id
		End If
	End If
	m_oUploaded.AddUploaded obj  
	WriteLog("Successfully uploaded and ID is: " & strId)
	UploadFile = True
End Function
 

' --------- RTC 176444: Update content of document --------------------

' Update Filepath and Doc_Id values in DCO
Public Function UpdateUploadInfoInDCO(tempObj,newFilePath,newId)    

  If (0<Len(newFilePath)) Then
    ' If there is a value for the filepath, update the DCO
  	strfile = tempObj.Variable("FILEUPLOADED")
		If (1>Len(strFile)) Then
      WriteLog("UpdateUploadInfoInDCO - setting FILEUPLOADED = " & newFilePath)
		  tempObj.Variable("FILEUPLOADED") = newFilePath	
		Else
      ' Append the new filepath to list of existing filepaths
			strFile = tempObj.Variable("FILEUPLOADED")
			strFile = strFile & "|" & newFilePath
      WriteLog("UpdateUploadInfoInDCO - setting FILEUPLOADED = " & strFile)
			tempObj.Variable("FILEUPLOADED") = strFile
	  End If
  End If
      
  If (0<Len(newId)) Then
    ' If there is a value for the doc ID, update the DCO
  	strId = tempObj.Variable("Doc_ID")
		If (1>Len(strId)) Then
       WriteLog("UpdateUploadInfoInDCO - setting Doc_ID = " & newId)
			 tempObj.Variable("Doc_ID") = newId	
		Else
      ' Append the new ID to list of existing IDs
			strId = tempObj.Variable("Doc_ID")
			strId = strId & "|" & newId
      WriteLog("UpdateUploadInfoInDCO - setting Doc_ID = " & strId)
			tempObj.Variable("Doc_ID") = strId
	  End If
  End If

End Function
  
  
  ' UpdateDocUsingDCO is recursive, used only if m_CreateMultiPageDoc=True (for updating multipage 
  ' documents to P8 as multiple content elements)
  Public Function UpdateDocUsingDCO(obj)
	  Dim DocImage
    Dim BatchDir
    Dim sDFile
    Dim sBFile 
	  Dim sImage
	  Dim sMFile	' name of file uploaded based on variable name
	  Dim sTmp  
    Dim Lie, nLie   
    
    UpdateDocUsingDCO = True		
  
    WriteLog("UpdateDocUsingDCO - start")

    Dim errStr
    
	  If Err.Number <> 0 Then
		  UpdateDocUsingDCO = False
		  errStr= "ERROR!!! N" + CStr(Err.Number) + vbCrLf _
			  + "Error description = " + Err.Description + vbCrLf _
			  + "Error Source = " + Err.Source
		  WriteLog(errStr)
		  Exit Function
	  End If
		       
    If Not m_DCOVariable="" Then	' if SetUploadMode is not blank, look in variables to find file to upload
	    If (obj.ObjectType < DCO_FIELD) Then
		    Dim strFile, id
		    sMFile = Pilot.BatchDir & "\"
		    sTmp = obj.Variable(m_DCOVariable)
        WriteLog("UpdateDocUsingDCO Page sMFile = " & sMFile)
        WriteLog("UpdateDocUsingDCO Page sTmp = " & sTmp)
		    
        if Len(sTmp)=0 Then
			    WriteLog("FNP8_Update action: DCO variable:'" &m_DCOVariable&"' missing or blank, nothing to upload for " & obj.ID)
		    Else			
			    Dim LastIndex
          WriteLog("UpdateDocUsingDCO sTmp = " & sTmp)
			    LastIndex = InStrRev(sTmp,":")
			    If LastIndex < 1 Then
				    LastIndex = InStrRev(sTmp,"\\")
				    If LastIndex < 1 Then
					    sMFile = sMFile & sTmp
				    Else
					    sMFile = sTmp'Full path stored in variable
				    End If
			    Else
				    sMFile = sTmp'Full path stored in variable
			    End If
			   
			    If m_oUploaded.IsFileUploaded(sMFile) Then
            WriteLog("UpdateDocUsingDCO - Skipping add for this file because it has already been updated: " & sMFile)
				    Exit Function ' skip if already uploaded
			    End If
          WriteLog("UpdateDocUsingDCO - Adding file " & sMFile)
		
          m_oP8Server.AddFile(sMFile)

          ' Add upload info, at this point we only have the filepath, not the Doc_Id
          UpdateUploadInfoInDCO obj,sMFile,""

          m_pageCount = m_pageCount + 1
         
          if IsRedactFileType(sImage) Then
		        WriteLog("Check for annotations page " & CStr(m_pageCount))
		        GetAnnotation obj,m_pageCount,sImage
	        End If
      
          UpdateDocUsingDCO = True
			    Exit Function
   	    End If	' end Len(sTmp) <> 0				
	    End If ' end DCO_PAGE
	
	    If ((sMFile = "") And (obj.ObjectType < DCO_PAGE)) Then
		    ' we didn't find any file of the requested type at this level, recurse down a level
        WriteLog("UpdateDocUsingDCO - we didn't find any file of the requested type at this level, recurse down a level")
		    For i = 0 To obj.NumofChildren-1
			    Set tmpObj = obj.GetChild(i)
			    WriteLog("UpdateDocUsingDCO FNP8_UpdateContent recurse to " & tmpObj.ID)
			    If (tmpObj.ObjectType < DCO_FIELD) Then UpdateDocUsingDCO(tmpObj)
		    Next
	    End If

	    Exit Function	'UploadMode was not blank
    End If ' UploadMode 

	  ' we arrive here only if UploadMode is blank
                
    on error resume next 'needed for uploading to "Unfiled Documents" folder only
    
  	'Search for Batch or Document level file from lower levels
	  Set DocImage = CurrentObj 'Needed for search for Documnet level image file
    If (CurrentObj.ObjectType > DCO_DOCUMENT) Then
    	Set DocImage = GetDocument(CurrentObj) 'searches for Document level object as a parent for current object
    End If
    sDFile = Pilot.BatchDir & "\" & DocImage.ID & m_FileType        
    
    If Not FileMgr.FileExists(sDFile) Then 	 'There is no Image on Doc level
	    Writelog("Document level image '" & sDFile & "' is not found, will search for Batch level image.")	
	    If m_BatchLevel=True Then
		    sBFile = Pilot.BatchDir & "\" & Pilot.BATCHID & m_FileType                                              
		    If Not FileMgr.FileExists(sBFile) Then       
			    'There is no Image on Doc and Batch Level
			    m_BatchLevel=False 'No Batch Level image, no need to check every time
		    Else
  			  WriteLog("Updating Batch Level file " & sBFile)
			    m_oP8Server.AddFile(sBFile)
           ' Add upload info, at this point we only have the filepath, not the Doc_Id
          UpdateUploadInfoInDCO obj,sBFile,""
          UpdateDocUsingDCO = True
			    Exit Function										
		    End If ' FileExists(sBFile)
  	  End If ' Batch Level
    Else  ' FileExists(sDFile) Document exists at document level
	    WriteLog("Added Document Level file for update: " & sDFile)
      m_oP8Server.AddFile(sDFile) 
       ' Add upload info, at this point we only have the filepath, not the Doc_Id
      UpdateUploadInfoInDCO obj,sDFile,""
      m_pageCount = 0   
      WriteLog("Added child pages (if they exist)")
      For i = 0 To CurrentObj.NumofChildren-1
        Set tmpObj = CurrentObj.GetChild(i)
        WriteLog("UpdateDocUsingDCO  iterating on child object with ID: " & tmpObj.ID)
        If (tmpObj.ObjectType = DCO_PAGE) Then             
            sImage = tmpObj.ImageName
            WriteLog("UpdateDocUsingDCO: sImage= " & sImage)
            if IsRedactFileType(sImage) Then      
                m_pageCount = m_pageCount + 1		            
		            GetAnnotation tmpObj,m_pageCount,sImage
	          End If        
        End If
      Next           
      UpdateDocUsingDCO = True
	    Exit Function				
    End If
   
    ' if we reach here, we are left with looking for document at page level
    
    sImage = obj.ImageName 
    If (obj.ObjectType = DCO_PAGE) Then
	    WriteLog("UpdateDocUsingDCO Uploading sImage " & sImage)
      m_oP8Server.AddFile(sImage)
      ' Add upload info, at this point we only have the filepath, not the Doc_Id
      UpdateUploadInfoInDCO obj,sImage,""
      
      m_pageCount = m_pageCount + 1
      if IsRedactFileType(sImage) Then
		    WriteLog("Check for annotations page" & CStr(m_pageCount))
		    GetAnnotation obj,m_pageCount,sImage
	    End If
      
      if(gFileNetP8.m_CreateMultiPageDoc = True) Then
        nLie = ubound(g_aPageList)
        WriteLog("UpdateDocUsingDCO ubound g_aPageList nLie = " & nLie)
	      Redim Preserve g_aPageList(nLie + 1)
        g_aPageList(nLie) = sImage
        nLie = ubound(g_aPageList)
        WriteLog("UpdateDocUsingDCO ubound second check g_aPageList nLie = " & nLie)
      End If
      WriteLog("UpdateDocUsingDCO done AddFile sImage " & sImage)
      UpdateDocUsingDCO = True
	    Exit Function
    End If
	
    If ((sImage = "") And (obj.ObjectType < DCO_PAGE)) Then
	    For i = 0 To obj.NumofChildren-1
		    Set tmpObj = obj.GetChild(i)
		    If (tmpObj.ObjectType < DCO_FIELD) Then 
			    UpdateDocUsingDCO(tmpObj)      
		    End If
	    Next  
    End If
  End Function
  

' UpdateDCO is called from FNP8_UpdateContent for single page  
Public Function UpdateDCO(obj,docID) 
	  Dim DocImage
    Dim BatchDir
    Dim sDFile
    Dim sBFile 
	  Dim sImage
	  Dim sMFile	' name of file updated based on variable name
	  Dim sTmp
    
    UpdateDCO = False
		
    WriteLog("UpdateDCO - m_DCOVariable: " & m_DCOVariable)
    WriteLog("UpdateDCO - ObjectType: " & obj.ObjectType)
    
    If Not m_DCOVariable="" Then	' if SetUploadMode is not blank, look in variables to find file to upload

	    If (obj.ObjectType < DCO_FIELD) Then		
		    Dim strFile, id
		    sMFile = Pilot.BatchDir & "\"		
		    sTmp = obj.Variable(m_DCOVariable)
		
		    if Len(sTmp)=0 Then
		      WriteLog("UpdateDCO: upload mode variable '" & m_DCOVariable & "' not set, nothing to upload for " & obj.ID)
	      Else	
          WriteLog("UpdateDCO: upload mode variable '" & m_DCOVariable & "' = '" & sTmp & "'")
	      	Dim LastIndex			
          LastIndex = InStrRev(sTmp,":")
			    If LastIndex < 1 Then
				    LastIndex = InStrRev(sTmp,"\\")
			      If LastIndex < 1 Then
			        sMFile = sMFile & sTmp
	  	      Else
					    sMFile = sTmp'Full path stored in variable
				    End If
			    Else
				    sMFile = sTmp'Full path stored in variable
			    End If

			    WriteLog("Updating " & sMFile)
			    If m_oUploaded.IsFileUploaded( sMFile ) Then
				    Exit Function
			    End If
		
			    UpdateDCO = UpdateFile(sMFile,obj,1,docID) ' hardcoded page number = 1
			    Exit Function
          ' End of handling when page mode variable value if found
        End If					
	    End If  ' End IF clause for checking for page mode variable at current level
      
	    If ((sMFile = "") And (obj.ObjectType < DCO_PAGE)) Then
		    WriteLog("UpdateDCO - we did not find any file of the requested type at this level, recurse down a level")
		    For i = 0 To obj.NumofChildren-1
			    Set tmpObj = obj.GetChild(i)
			    WriteLog("UpdateDCO recurse to " & tmpObj.ID)
			    If (tmpObj.ObjectType < DCO_FIELD) Then
            Call UpdateDCO(tmpObj,docID)
          End If
		    Next
	    End If  ' End IF clause for recursively checking for page mode variable at current level

	    Exit Function	'UploadMode was not blank
									
    End If   ' End of IF clause for when UploadMode is not blank
    
    ' Start handling for when UploadMode is blank and FNP8_SetMultiPageDocs was not set to true
    WriteLog("UpdateDCO - UploadMode is blank. Checking pageNames for duplicate IDs")
              
    ' Make sure there are not multiple content elements from the P8 document
    If (obj.ObjectType < DCO_PAGE) Then
      Set docObj = obj       
      If (obj.ObjectType = DCO_BATCH) Then
        docObj = obj.GetChild(0)
      End If
      
      If (docObj.NumofChildren > 1) Then
        prevID = docObj.GetChild(0).Variable("PageName")
	      For i = 1 To docObj.NumofChildren-1
			    Set pageObj = docObj.GetChild(i)
          If (pageObj.Variable("PageName") = prevID) Then
			      ' WriteLog("Error: FNP8_UpdateContent - The document has multiple pages with same object ID: " & prevID)
            ' WriteLog("Call FNP8_SetMultiPageDocs(True) before calling FNP8_UpdateContent() for P8 documents with multiple content elements.")
            Err.Raise 1,"FileNetP8.rrx","Upload failed: The document has multiple pages with same object ID.  Call FNP8_SetMultiPageDocs(True) for P8 documents with multiple content elements."
            Exit Function
          End If 
			    prevID = pageObj.Variable("PageName")
		    Next
      End If
    End If
    
    on error resume next 'needed for uploading to "Unfiled Documents" folder only

	  'Search for Batch or Document level file from lower levels	
	  Set DocImage = CurrentObj 'Needed for search for Documnet level image file
      
    If (CurrentObj.ObjectType > DCO_DOCUMENT) Then
	    Set DocImage = GetDocument(CurrentObj) 'searches for Document level object as a parent for current object
    End If
		
    sDFile = Pilot.BatchDir & "\" & DocImage.ID & m_FileType                                              
			        
    If Not FileMgr.FileExists(sDFile) Then 	 'There is no Image on Doc level
	    'Writelog("Document level image '" & sDFile & "' is not found, will search for Batch level image.")	
        
	    If m_BatchLevel=True Then
		    sBFile = Pilot.BatchDir & "\" & Pilot.BATCHID & m_FileType                                              
		    If Not FileMgr.FileExists(sBFile) Then       
		      'There is no Image on Doc and Batch Level
		 	    'Writelog("Batch level iamge '" & sBFile & "' is not found, uploading image by image.")	
		      m_BatchLevel=False 'No Batch Level image, no need to check every time
		    Else
  	      WriteLog("Updating Batch Level file " & sBFile)
			    UpdateDCO = UpdateFile(sBFile,obj,1,docID)
			    Exit Function										
		    End If
	    End If		
      
    Else
	    WriteLog("Updating Document Level file " & sDFile)
	    UpdateDCO = UpdateFile(sDFile,obj,1,docID)
	    Exit Function				
    End If

    sImage = obj.ImageName
    If (obj.ObjectType = DCO_PAGE) Then
	    WriteLog("UpdateDCO Updating sImage " & sImage)
	    UpdateDCO = UpdateFile(sImage,obj,1,docID)
	    Exit Function
    End If
	
    If ((sImage = "") And (obj.ObjectType < DCO_PAGE)) Then
	    For i = 0 To obj.NumofChildren-1
		    Set tmpObj = obj.GetChild(i)
		    If (tmpObj.ObjectType < DCO_FIELD) Then 
		      Call UpdateDCO(tmpObj,docID)
		    End If
	    Next
    End If
     
	  UpdateDCO = True
     
End Function


' UpdateFile calls server.Update to UPdate one file and then the redaction info if any
' only called for single page doc

Public Function UpdateFile(sFile,obj,pageNumber,docID)
 'pageNumber now 1-based
	on Error Resume Next
	If m_oUploaded.IsFileUploaded( sFile ) Then 
		UpdateFile = True
		Exit Function
	End If
      
	m_FileType=CheckFileType(sFile)
  WriteLog("UpdateFile: File Type: " + m_FileType)
  
  if IsRedactFileType(sFile) Then
		WriteLog("UpdateFile: Check for annotations")
		GetAnnotation obj,pageNumber,sFile		
	End If
  m_oP8Server.AddFile(sFile)
	strId = m_oP8Server.UpdateContent(docID)	
			
	If Err.number<>0 Then			
		ErrorHandler()
		UpdateFile = False
		Exit Function
	End If

	If (strId = "") Then
		Err.Raise 1,"FileNetP8.rrx","Update failed: the results do not contain a document ID..."
		UpdateFile = False
		Exit Function
	Else
    UpdateUploadInfoInDCO obj,sFile,strId
	End If
	
  m_oUploaded.AddUploaded obj  
	WriteLog("FNP8_UpdateContent Successfully updated document.  New ID is: " & strId)
	UpdateFile = True
  
End Function
	
  ' --------- END: RTC 176444: Update content of document --------------------

Public Function GetSpecialVariable(str, oDCO)
		GetSpecialVariable = str
		Dim tStr 
		tStr = Metaword(str)
		if Len(tStr)>0 Then
			GetSpecialVariable = tStr
			Exit Function
		End If

		  'DCO special variables:				
			'@BATCHID		- DCO BatchID
			'@ID				- DCO ID
			'@STATUS		- DCO Status
			'@TYPE			- DCO Type
			'@VALUE			- DCO Value
		'TM special variables:
			'@JOBID			- TM JobID		
			'@JOBNAME		- TM JobName
			'@OPERATOR	- TM Operator
			'@STATION		- TM Station
			'@TASKID		- TM TaskID
			'@TASKNAME	- TM TaskName

		If Left(str, 1) = "@" Then 
			Select Case str
			'DCO special variables				
				Case "@BATCHID"
					GetSpecialVariable = Pilot.BatchID 
				Case "@ID"
					GetSpecialVariable = oDCO.ID
				Case "@STATUS"
					GetSpecialVariable = oDCO.Status
				Case "@TYPE"
					GetSpecialVariable = oDCO.Type
				Case "@VALUE"
					GetSpecialVariable = oDCO.Text
			'TM special variables
				Case "@JOBID"
					GetSpecialVariable = Pilot.JobID
				Case "@JOBNAME"
					GetSpecialVariable = Pilot.JobName
				Case "@OPERATOR"
					GetSpecialVariable = Pilot.Operator
				Case "@STATION"
					GetSpecialVariable = Pilot.Station
				Case "@TASKID"
					GetSpecialVariable = Pilot.TaskID
				Case "@TASKNAME"
					GetSpecialVariable = Pilot.TaskName
				Case Else
					GetSpecialVariable = oDCO.Variable(Right(str, Len(str)-1)) 'Variable Value
			End Select

			If (GetSpecialVariable = "") Then	'Field Value
				Set oChild = oDCO.FindChild(Right(str, Len(str)-1))
				If Not(oChild Is Nothing) Then
					GetSpecialVariable = oChild.Text
					Set oChild = Nothing
				End If
			End If

			WriteLog("GetSpecialVariable returns: " & GetSpecialVariable)
		End If
	End Function
	
	Public Function GetDocument(oCurDCO) ' Works only from lower levels
		Dim oDocument
		Set oDocument = oCurDCO

		If (oDocument.ObjectType > DCO_DOCUMENT) Then
			Set oDocument = GetDocument(oCurDCO.Parent)
		End If

	 	Set GetDocument = oDocument	
	End Function


	Private Function ClearError()
		If Err.Number = -2146233087 Then 
        		'We need to handle errors by error description

			'Ignore No Valid OOID for "Unfiled Folder" 
			If InStr(err.description,"The supplied buffer does not contain a valid OIID") <> 0 Then
				Err.Clear 
				WriteLog("Error " & err.Number & " '" & err.Description & " '" & "has been cleared...")
			End If
			
			'Write to Log error information about seting mulit to single value property
	        	If InStr(err.description,"The method invoked is inappropriate for the datatype of the property") <> 0 Then
                		WriteLog("ERROR!!! Couldn't assign multiple values to a single value propertty or the data type is invalid. Please check if the correct data type specified.") 
			End If
		End If
	End Function
	Public Function ErrorHandler()
		ErrorHandler = True
      
		ClearError()
         
		If Err.Number <> 0 Then
			Dim Str			
			Str= "ERROR!!! N" + CStr(Err.Number) + vbCrLf _
 				+ "Error description = " + Err.Description + vbCrLf _
				+ "Error Source = " + Err.Source
			Err.Clear
			WriteLog(Str)
			'Set Task to Abort				
			bAbort = True
			nTaskStatus = RetAbort 	

			ErrorHandler = False
       
			m_oP8Server.ClearProperties
		End If	
	End Function

  ' Similar to ErrorHandler but return false without setting task to abort
	Public Function ErrorHandlerWithoutAbort()
		ErrorHandlerWithoutAbort = True
      
		ClearError()
         
		If Err.Number <> 0 Then
			Dim Str			
			Str= "ERROR!!! N" + CStr(Err.Number) + vbCrLf _
 				+ "Error description = " + Err.Description + vbCrLf _
				+ "Error Source = " + Err.Source
			Err.Clear
			WriteLog(Str)

      ' Return false
			ErrorHandlerWithoutAbort = False
       
			m_oP8Server.ClearProperties
		End If	
	End Function
  
	Public Function GetMimeType(fExt) 'Returns the MIME type according to extension
		fExt = LCase(fExt)

		'Custom MIME type overrides default list
		If customMimeTypes.Exists(fExt) Then
			GetMimeType = customMimeTypes.Item(fExt)
			Exit Function
		End If
  
		Select Case fExt 'Supported MIME Types
			Case ".ai"
				GetMimeType = "application/illustrator"
			Case ".avi"
				GetMimeType = "video/x-msvideo"
			Case ".bmp"
				GetMimeType = "image/bmp"
			Case ".doc"
				GetMimeType = "application/msword"
			Case ".docx"
				GetMimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
			Case ".dwg"
				GetMimeType = "image/vnd.dwg"
			Case ".dxf"
				GetMimeType = "image/vnd.dxf"
			Case ".gif"
				GetMimeType = "image/gif"
			Case ".htm"
				GetMimeType = "text/html"
			Case ".html"
				GetMimeType = "text/html"
			Case ".ico"
				GetMimeType = "image/x-icon"
			Case ".jpe"
				GetMimeType = "image/jpeg"
			Case ".jpeg"
				GetMimeType = "image/jpeg"
			Case ".jpg"
				GetMimeType = "image/jpeg"
			Case ".jpgv"
				GetMimeType = "video/jpeg"
			Case ".m4v"
				GetMimeType = "video/x-m4v"
			Case ".mov"
				GetMimeType = "video/quicktime"
			Case ".mp4"
				GetMimeType = "video/mp4"
			Case ".mpeg"
				GetMimeType = "video/mpeg"
			Case ".mpg"
				GetMimeType = "video/mpeg"
			Case ".mpp"
				GetMimeType = "application/vnd.ms-project"
			Case ".mpv"
				GetMimeType = "video/mpv"
			Case ".msg"
				GetMimeType = "application/msoutlook"
			Case ".ogg"
				GetMimeType = "application/ogg"
			Case ".pcx"
				GetMimeType = "image/x-pcx"
			Case ".pdf"
				GetMimeType = "application/pdf"
			Case ".pic"
				GetMimeType = "image/x-pict"
			Case ".png"
				GetMimeType = "image/png"
			Case ".ppt"
				GetMimeType = "application/vnd.ms-powerpoint"
			Case ".pptx"
				GetMimeType = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
			Case ".qt"
				GetMimeType = "video/quicktime"
			Case ".rgb"
				GetMimeType = "image/x-rgb"
			Case ".rtf"
				GetMimeType = "text/richtext"
			Case ".tif"
				GetMimeType = "image/tiff"
			Case ".tiff"
				GetMimeType = "image/tiff"
			Case ".txt"
				GetMimeType = "text/plain"
			Case ".vsd"
				GetMimeType = "application/vnd.visio"
			Case ".wmd"
				GetMimeType = "application/x-ms-wmd"
			Case ".wmv"
				GetMimeType = "video/x-ms-wmv"
			Case ".wmx"
				GetMimeType = "video/x-ms-wmx"
			Case ".xls"
				GetMimeType = "application/vnd.ms-excel"
			Case ".xlsx"
				GetMimeType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
			Case ".xml"
				GetMimeType = "text/xml"
			Case ".zip"
				GetMimeType = "application/x-zip-compressed"
			Case Else
				Writelog ("'" & fExt &"' is not supported. Using default value 'application/octet-stream'")				
				GetMimeType = "application/octet-stream" 'Default Value
		End Select
	End Function

	Public Function CheckFileType(fName)	' set MIME type based on filename suffix
		Dim LastIndex,Size
		LastIndex = InStrRev(fname,".")
		Size = Len(fName)-LastIndex+1
		If Not (m_FileType=Right(fName,Size)) Then 'If file type is different from uploading image
			m_FileType=Right(fName,Size)	   ' we need to set Mime type for uploadig Image type
			Writelog("File type set to '" & m_FileType & "'") 
			m_oP8Server.SetMimeType (GetMimeType(m_FileType))
			Writelog("MIME Type set to '" & GetMimeType(m_FileType)&"'")
		End If
               CheckFileType=m_FileType
	End Function
	
	Public Function IsRedactFileType(fName)	' check whether we support redaction on this file type
		Dim LastIndex,Size
		LastIndex = InStrRev(fname,".")
		Size = Len(fName)-LastIndex+1
		sFileSuffix=Right(fName,Size)	   ' we need to set Mime type for uploadig Image type
      
    IsRedactFileType = False
	  If sFileSuffix = ".tif" or sFileSuffix = ".tiff" or sFileSuffix = ".jpg" or sFileSuffix = ".jpeg" Then	IsRedactFileType = True
  End Function
  
	Public Function GetResolution(fName)	' set MIME type based on filename suffix to upload
		Dim LastIndex,Size
		LastIndex = InStrRev(fname,".")
		Size = Len(fName)-LastIndex+1
		If Not (m_FileType=Right(fName,Size)) Then 'If file type is different from uploading image
			m_FileType=Right(fName,Size)	   ' we need to set Mime type for uploadig Image type
			Writelog("File type set to '" & m_FileType & "'") 
			m_oP8Server.SetMimeType (GetMimeType(m_FileType))
			Writelog("MIME Type set to '" & GetMimeType(m_FileType)&"'")
		End If
               CheckFileType=m_FileType
	End Function
	
  Public Function GetResolutionDPI(CurrentObj,filename)
    GetResolutionDPI = 200
    Dim ImageCtrl  ' DC Image Object
    
    Writelog("Get the Resolution DPI for file: " & filename)
    
    if(filename="") Then
      Writelog("Error: Current object is not assosciated with an image.")
      exit function
    end if
    
    Writelog("Open the DCIMAGE.DcimageCtrl.1")
      Set ImageCtrl = CreateObject("DCIMAGE.DcimageCtrl.1")
      Writelog("Open the DCIMAGE.DcimageCtrl.1 complete")
      ImageCtrl.FileName = filename
			ImageCtrl.GetImageInfo Width, Height, DPI
			ImageCtrl.GetRes xDPI, yDPI
      Writelog "image name " & ImageCtrl.FileName
      Writelog "image DPI (Bit count)" &  CStr(DPI)
      Writelog "image xDPI, yDPI " & xDPI & " " & yDPI			
      GetResolutionDPI = xDPI
      Set ImageCtrl = nothing
  End Function
  
    


  ' GetAnnotation
  ' Find all redaction fields on this page, send via DC_P8_Server to P8 along with the audit trail
  ' called by UploadFile on page level only, for supported image file types
  '
	Public Function GetAnnotation(CurrentObj,pageNumber,filename)	
    ' Pagenumber now one-based
		' Sensitive content property, default = null (not scanned) or:
    Const SI_OURNULL = -1 ' not used in P8
    Const  SI_NoSensitiveContent = 0
    Const  SI_SensitiveContent = 1
		Dim oChildPage ' a field on this page
    Dim Resolution
    Dim bRet
    Dim bAnyRedaction ' if any redactions exist
    Dim bOCRScanned ' if an OCR scan created any redaction
    Dim iStatus
    
    iNumChildren = CurrentObj.NumOfChildren	
		Writelog("GetAnnotation check for redactions, page " & CStr(pageNumber)) 
    Resolution = GetResolutionDPI(CurrenObj,filename)
		bAnyRedaction = False
    bOCRScanned = False
		For i=0 to CurrentObj.NumOfChildren-1		
			Set oChildPage = CurrentObj.GetChild(i)
      if oChildPage.ObjectType = DCO_FIELD then
			  bRet = FindRedactionValue(oChildPage,pageNumber,Resolution)
        if (bRet) then 
          bAnyRedaction = True
        End If
      End If
		Next
		
    ' pass per-page audit trail XML from DCO to the server, if available
    ' NSK TBD does this ened to be per-document?
    sRedactAudit = CurrentObj.Variable("RedactionAudit")
    if (sRedactAudit <> "") then m_oP8Server.AddAuditScanRedactFieldName(sRedactAudit) ' send audit record from this page to P8_Server to extract fields and reasons
    
    ' if any redactions were searched for (IsOCRRedaction set for any field), or any manual redactions exist ,set Sensitive Data property
    ' NSK is sensitive content stored per page or doc? Now we set Sensitive Content each time a page is uploaded in the doc
    ' NSK TBD? accumulate sensitive content over all pages in the doc. If any page was scanned, we say the doc was scanned.
    if InStr(sRedactAudit, "ReasonName=") and InStr(sRedactAudit, "processName=") and InStr(sRedactAudit, "Datacap OCR") then
      bOCRScanned = True
    End If
    
    if bOCRScanned then m_sensitiveScan = True
    if bAnyRedaction then m_sensitiveContent = True
    
    iStatus = SI_OURNULL
    if bAnyRedaction or bOCRScanned then 
      if not bAnyRedaction then 
          iStatus = SI_NoSensitiveContent	
      else
          iStatus = SI_SensitiveContent	
      End If
      Writelog "GetAnnotation - sensitive status of page: " & iStatus
    End If
      
    iStatus = SI_OURNULL
    if m_sensitiveContent or m_sensitiveScan then 
      if not m_sensitiveContent then 
          iStatus = SI_NoSensitiveContent	
      else
          iStatus = SI_SensitiveContent	
      End If
      
      if iStatus <> SI_OURNULL then
        Writelog "GetAnnotation - sensitive status of doc: " & iStatus
        m_oP8Server.SetSensitiveContent iStatus
      End If
    End if
	
  End Function
	
  '
  ' FindRedactionValue
  ' If this field is a redaction, add it to the server collection for this document
  ' Returns False for no redaction, True for redaction found
  '
	Public Function FindRedactionValue(oField,pageNumber,resolution)
    ' pageNumber now 1-based
    FindRedactionValue = False
    l_sVarName = ""
    l_sVarValue = ""
    l_sVarIsRedaction = ""
    l_sVarReasonCode = ""
    l_sVarPosition = ""
    
    
    'Writelog("Getting Detail Field Info for: " & oField.ID)
    l_iNumVars = oField.NumOfVars
    'Writelog oField.ID & " contains " & l_iNumVars & " variables."
    
    l_sVarIsRedaction = ""
    l_sVarIsRedaction = oField.Variable("IsRedaction")
    'Writelog "FindRedactionValue - IsRedaction Value: " & l_sVarIsRedaction    
    
    If l_sVarIsRedaction = "1" Then
       l_sVarReasonCode = oField.Variable("ReasonCode")
       Writelog "FindRedactionValue - Reason ID: " & l_sVarReasonCode 
       Writelog "FindRedactionValue - Field Type: " & oField.Type 
       l_sVarPosition = oField.Variable("Position")
       Writelog "FindRedactionValue - Position: " & l_sVarPosition 
       Writelog "Add Annotation"       
       m_oP8Server.AddAnnotationResolution pageNumber, "",l_sVarPosition,resolution,l_sVarReasonCode,l_sVarReasonCode       		 
       FindRedactionValue = True
    End If        
    
	End Function
  
  
  
	'Private methods ------------------------------------------------------
	'None


End Class	'CFileNetP8
'------------------------------------------------------

'------------------------------------------------------
'	C_UploadedXML_P8
'------------------------------------------------------

Class C_UploadedXML_P8
	Private m_dcoUploaded
	Private m_dcoFileName
	
	Private Sub Class_Initialize	' Initialize event
		Set m_dcoUploaded = CreateObject("Tdco.Batch")
		 
		FilePath = Pilot.BatchDir
		FileName = "\P8_Uploaded.xml"

		m_dcoFileName = FilePath & FileName
		
		If FileMgr.FileExists(m_dcoFileName) Then
			Writelog("P8_Uploaded Xml file found.")
			m_dcoUploaded.Read(m_dcoFileName)
		Else
			Writelog("Creating New P8_Uploaded Xml file.")
			m_dcoUploaded.ID = DCO.ID
			m_dcoUploaded.Write(m_dcoFileName)
		End If
	End Sub
	
	
	Private Sub Class_Terminate		' Terminate event.
		'Save data first!!
		Call m_dcoUploaded.Write(m_dcoFileName)
		Set m_dcoUploaded = Nothing
	End Sub


	Public Function IsUploaded( oDCOPage )
		IsUploaded = False
	
		Set oChildpg = m_dcoUploaded.FindChild(oDCOPage.ID)
		If Not(oChildpg Is Nothing) Then 		
			Dim childArray, dcoArray, filenetIDs, uploadedArray
			childArray = Split(oChildpg.Variable("FILEUPLOADED"),"|")
                        dcoArray = Split(oDCOPage.Variable("FILEUPLOADED"),"|")
			fileneIDs = Split(oDCOPage.Variable("Doc_ID"),"|")
			uploadedArray = Split(oChildpg.Variable("Uploaded"),"|")
			Dim K
			K=0
			For Each dcoPage In dcoArray
				For Each childPage in childArray
					If Ucase(childPage)=Ucase(dcoPage) Then
						Writelog("File " & dcoPage & " already uploaded on " & uploadedArray(K) & " FileNet DocID: " & fileneIDs(K))
						IsUploaded = True
						Set oChildpg = Nothing
						Exit Function
					End If					
				Next
				K=K+1
			Next

		End If
		Set oChildpg = Nothing
	End Function

	Public Function IsFileUploaded( sFile )
		IsFileUploaded = False
		
		Dim N
		N = m_dcoUploaded.NumOfChildren
		For I=0 to N
 			Set oUploaded = m_dcoUploaded.GetChild(I)
			If Not(oUploaded Is Nothing) Then 		
						
				DIM filedArray,filenetIDs,uploadedArray
				fileArray = Split(oUploaded.Variable("FILEUPLOADED"),"|")
				
                	        uploadedArray = Split(oUploaded.Variable("Uploaded"),"|")
				fileneIDs = Split(oUploaded.Variable("Doc_ID"),"|")		
				Dim K
				K=0							
				For Each file In fileArray

					If Ucase(file)=Ucase(sFile) Then
						Writelog("File " & file & " already uploaded on " & uploadedArray(K) & " FileNet DocID: " & fileneIDs(K))
						IsFileUploaded = True
						Exit Function
                	
					End If
				K=K+1
				Next

			End If
		Next
		Set oUploaded = Nothing
	End Function

  Public Function AddNewDoc(file,strID)
    if CurrentObj is Nothing then  
      WriteLog("AddDCOPage CurrentObj is nothing")
      exit Function
    End If
           
    On Error Resume Next
     AddNewDoc = False
   
    WriteLog("AddNewDoc Process CurrentObj.ID = " & CurrentObj.ID)    
	  WriteLog("AddNewDoc Process strID = " & strId)	
    WriteLog("AddNewDoc Process file = " & file)	
    
    Set oDocument = m_dcoUploaded.AddChild(DCO_DOCUMENT, "", -1)
    If (oDocument Is Nothing) Then
	    WriteLog(" AddNewDoc.AddChild Doc failed")	    
    Else
	    WriteLog(" AddNewDoc.AddChild Doc success")	    
      oDocument.Variable("Doc_ID") = strID          
			oDocument.Variable("Uploaded")=CStr(Now)	    
	    m_dcoUploaded.Write(m_dcoFileName)      
      
       Set oNewPage = oDocument.AddChild(DCO_PAGE, "", -1)
        If (oNewPage Is Nothing) Then
	        WriteLog(" AddNewDoc.AddChild Page failed")	    
        Else
	        WriteLog(" AddNewDoc.AddChild Page success")
	        oNewPage.Variable("FILEUPLOADED") = file              	    
	        oUploaded.Write(m_dcoFileName)     
          WriteLog("AddNewDoc add page object = " & file)
        End If           
    End If
    
   'oUploaded.Write(m_dcoFileName) 
   WriteLog(" AddNewDoc.AddChild Final Write")
   Call m_dcoUploaded.Write(m_dcoFileName)
   AddNewDoc = True
  End Function
  
	Public Function UpdateDCODoc(CurrentObj,strID)	
    if CurrentObj is Nothing then  
      WriteLog("dUpdateDCODoc CurrentObj is nothing")
      exit Function
    End If
    
    WriteLog("UpdateDCODoc Process CurrentObj.ID = " & CurrentObj.ID)    
	  WriteLog("UpdateDCODoc Process strID = " & strId)	
    WriteLog("UpdateDCODoc Process Filenet document ID = " & strId)	
    CurrentObj.Variable("Doc_ID") = strID
    
    Dim N
    Dim currentDocID
		N = m_dcoUploaded.NumOfChildren
		For I=0 to N
 			Set oUploaded = m_dcoUploaded.GetChild(I)
			If Not(oUploaded Is Nothing) Then 	      
        WriteLog("UpdateDCODoc oUploaded.ID = " & oUploaded.ID)    
	      WriteLog("UpdateDCODoc strID = " & strId)	        
        currentDocID = oUploaded.Variable("Doc_ID")
        WriteLog("UpdateDCODoc currentDocID = " & currentDocID)
        If (currentDocID = "") Then
          WriteLog("CreateDCODoc oUploaded update")        
	        oUploaded.Variable("Doc_ID") = strID          
			    oUploaded.Variable("Uploaded")=CStr(Now)
	        m_dcoUploaded.Write(m_dcoFileName)  
          
         'Add the pages to the doc
         WriteLog("CreateDCODoc start processing pages")
         Dim nPage         
         Dim pageName
         Dim nTotalPages
         Dim oNewPage
         
         nTotalPages = ubound(g_aPageList)
         WriteLog("UpdateDCODoc total pages = " & nTotalPages)
         
         For nPage = 0 to ubound(g_aPageList)-1
          If g_aPageList(nPage)<>"" then
            pageName = g_aPageList(nPage)
            WriteLog("CreateDCODoc extract page = " & pageName) 
            
            Set oNewPage = oUploaded.AddChild(DCO_PAGE, "", -1)
            If (oNewPage Is Nothing) Then
	            WriteLog(" CreateDCODoc.AddChild failed")	    
            Else
	            WriteLog(" CreateDCODoc.AddChild success")
	            oNewPage.Variable("FILEUPLOADED") = pageName              	    
	            oUploaded.Write(m_dcoFileName)     
              WriteLog("CreateDCODoc Update Page object = " & pageName)
            End If
          Else ' page = ""
            WriteLog(" UpdateDCODoc, value from page array is blank")      
          End if
        Next 'nPage                
         
        Erase g_aPageList
        m_dcoUploaded.Write(m_dcoFileName) 
        Exit Function
      Else ' CurrentDocID <> ""
        WriteLog(" UpdateDCODoc has a current ID currentDocID = " & currentDocID)
      End If         			  ' CurrentDocID
		End If  ' Not(oUploaded)
	Next ' I
  
  
  End Function
    
  Public Function CreateDCODoc()
    On Error Resume Next
     CreateDCODoc = False
   
    Set oChildPg = m_dcoUploaded.AddChild(DCO_DOCUMENT, "", -1)
    If (oChildPg Is Nothing) Then
	    WriteLog(" CreateDCODoc.AddChild failed")	    
    Else
	    WriteLog(" CreateDCODoc.AddChild success")	    
      oChildPg.Variable("Doc_ID") = ""	    
	    m_dcoUploaded.Write(m_dcoFileName)      
      
      ReDim g_aPageList(0)  ', CFileNetP8
      
    End If
   CreateDCODoc = True
  End Function
  
Public Function AddUploadedFile(strFile)
   WriteLog("AddUploadedFile filename = " & strFile)
   Call m_dcoUploaded.Write(strFile)
End Function

	Public Function AddUploaded( oDCOPage )
    
		Set oChildpg = m_dcoUploaded.FindChild(oDCOPage.ID)
    
		If (oChildpg Is Nothing) Then 
			Set oChildPg = m_dcoUploaded.AddChild(2, oDCOPage.ID, -1)
			If (oChildPg Is Nothing) Then
				Err.Raise 1, "FileNetP8.rrx", "Cannot create DCO child...",  "", ""
				Exit Function
			End If

			'Dim file,fileArray
			'Dim uploaded,uploadedArray
			'Dim id, idArray
                        'fileArray=split(oChildPg.Variable("FILEUPLOADED"),"|")
                        'idArray=Split(oChildPg.Variable("Doc_ID"),"|")
			'uploadedArray=Split(oChildPg.Variable("Uploaded"),"|")
			'For Each file in fileArray
				
		End If
			'Next
			Dim Test
			test = oDCOPage.Variable("FILEUPLOADED")
			oChildPg.Variable("FILEUPLOADED") = oDCOPage.Variable("FILEUPLOADED")
      oChildPg.Variable("Doc_ID") = oDCOPage.Variable("Doc_ID")
			Dim tmpUploaded
			tmpUploaded = oChildPg.Variable("Uploaded")

			If (1>Len(tmpUploaded)) Then
				tmpUploaded= CStr(Now)
			Else
				tmpUploaded=tmpUploaded & "|" & CStr(Now)
			End If			
			oChildPg.Variable("Uploaded") =tmpUploaded

			Set oChildPg = Nothing
		


    Call m_dcoUploaded.Write(m_dcoFileName)
	End Function
	
End Class 'C_UploadedXML_P8

'------------------------------------------------------
'End Global entries 
'------------------------------------------------------


Function FNP8_SetURL(bInter, bDebug, StrParam) 
	FNP8_SetURL = False
	On Error Resume Next
	
	Str = MetaWord(StrParam)	
	If len(Trim(Str))=0 Then Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)	
  Writelog("URL = '" & Str & "'")
  gFileNetP8.m_oP8Server.SetURL Str
  
	FNP8_SetURL = gFileNetP8.ErrorHandler()

End Function

Function FNP8_Login(bInter, bDebug, StrParam) 
	FNP8_Login = False

	On Error Resume Next
	Dim aStrParam
	Dim sUser
	Dim sPassword	
	Dim sSmartParam
	
	aStrParam = Split(StrParam, ",", -1, 1) 	
	sUser = Trim(aStrParam(0))
  
  sUser=MetaWord(sUser)
	If len(Trim(sUser))=0 Then sUser = gFileNetP8.GetSpecialVariable(sUser, CurrentObj)	
    
	sPassword = Trim(aStrParam(1))
  sPassword=MetaWord(sPassword)  
  If len(Trim(sPassword))=0 Then sPassword = gFileNetP8.GetSpecialVariable(sPassword, CurrentObj)	
  
	If(sUser="" Or sPassword="") Then
		bAbort = True
		nTaskStatus = RetAbort 	
		WriteLog("Error in FNP8_Login action: Specified parameter is invalid.")
		Exit Function
	End If

  'check user name
  Dim sDecrypted  
  dDecrypted = "" 
  'Attempt to decrypt password
  bRes = RRState.SecureCallAA("5391195122688068107","5023835650813708667",sUser,sDecrypted)   
  If bRes=False Then 
     Writelog("User Decryption call returned false.")
  Else
     Writelog("User has been decrypted.") 
     sUser = sDecrypted
     'Writelog("sDecrypted = "& sDecrypted) ' FOR DEBUG ONLY - MAKE SURE THIS IS COMMENTED FOR PRODUCTION
     'Writelog("sUser = "& sUser) ' FOR DEBUG ONLY - MAKE SURE THIS IS COMMENTED FOR PRODUCTION
  End if    
  
  'check password  
  dDecrypted = "" 
  'Attempt to decrypt password
  bRes = RRState.SecureCallAA("5391195122688068107","5023835650813708667",sPassword,sDecrypted)   
  If bRes=False Then 
     Writelog("Password Decryption call returned false.")
  Else
     Writelog("Password has been decrypted.") 
     sPassword = sDecrypted
     'Writelog("sDecrypted = "& sDecrypted) ' FOR DEBUG ONLY - MAKE SURE THIS IS COMMENTED FOR PRODUCTION
     'Writelog("sPassword = "& sPassword) ' FOR DEBUG ONLY - MAKE SURE THIS IS COMMENTED FOR PRODUCTION
  End if    
  
	On Error Resume Next
	gFileNetP8.m_oP8Server.Login sUser, sPassword
	FNP8_Login = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetLocale(bInter, bDebug, StrParam) 
	FNP8_SetLocale = False

	On Error Resume Next
  
  StrParam=MetaWord(StrParam)  
  If len(Trim(StrParam))=0 Then StrParam = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  
	gFileNetP8.m_oP8Server.SetLocale StrParam
	FNP8_SetLocale = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetTargetClassID(bInter, bDebug, StrParam) 
	FNP8_SetTargetClassID = False

	On Error Resume Next
  
  StrParam=MetaWord(StrParam)  
  If len(Trim(StrParam))=0 Then StrParam = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  
	gFileNetP8.m_oP8Server.SetTargetClassID StrParam
	FNP8_SetTargetClassID = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetTargetObjectID(bInter, bDebug, StrParam) 
	
	FNP8_SetTargetObjectID = False

	On Error Resume Next
	
	Str = MetaWord(StrParam)
	If len(Trim(Str))=0 Then Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)	
	gFileNetP8.m_oP8Server.SetTargetObjectID Str
	
	FNP8_SetTargetObjectID = gFileNetP8.ErrorHandler()
	

End Function

Function FNP8_SetDestinationFolder(bInter, bDebug, StrParam) 
	FNP8_SetDestinationFolder = False

   WriteLog("FNP8_SetDestinationFolder: " & StrParam)
	Str = MetaWord(StrParam)
  WriteLog("FNP8_SetDestinationFolder (metaword): " & Str)
  If len(Trim(Str))=0 Then Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)  
  
   WriteLog("SetDestinationFolder (param): " & Str)
	gFileNetP8.m_oP8Server.SetDestinationFolder Str
      
	FNP8_SetDestinationFolder = gFileNetP8.ErrorHandler()

End Function

Function FNP8_CreateFolder(bInter, bDebug, StrParam) 

  On Error Resume Next
  
    FNP8_CreateFolder = False
      
    strFolder = MetaWord(StrParam)
    If len(Trim(StrFolder))=0 Then strFolder = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)

	  WriteLog("Destination folder: " & gFileNetP8.m_oP8Server.GetDestinationFolder())
	
    strId = gFileNetP8.m_oP8Server.CreateFolder(strFolder)
    
    If (strId = "") Then
		  WriteLog("The results do not contain a folder ID...")
	  Else
		  CurrentObj.Variable("Folder_ID") = strId
		  WriteLog("Successfully created and ID is: " & strId & "; Destination folder is changed to: " & gFileNetP8.m_oP8Server.GetDestinationFolder())
	  End If

   ' This check is not needed.  DC_P8_Server code is already performing a check for existing folder.  This error check below is masking actual errors in create folder
	 ' If Err.Number = -2146233088 Then 'Ignore not unique folder name for rollback capability support		
	 '	  Err.clear			  
	 '	  Writelog("Folder " & gFileNetP8.m_oP8Server.GetDestinationFolder & " already exists." & " Uploading to folder specified")		  
	 ' End If

	  gFileNetP8.m_oP8Server.ClearProperties
	  FNP8_CreateFolder = gFileNetP8.ErrorHandler()
    

End Function

Function FNP8_SetDocClassId(bInter, bDebug, StrParam) 
	FNP8_SetDocClassId = False
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
	gFileNetP8.m_oP8Server.SetDocClassId Str
	FNP8_SetDocClassId = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetDefineSecurityParentage(bInter, bDebug, StrParam) 
  FNP8_SetDefineSecurityParentage = False
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  gFileNetP8.m_oP8Server.SetDefineSecurityParentage Str
  FNP8_SetDefineSecurityParentage = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetDocTitle(bInter, bDebug, StrParam) 
FNP8_SetDocTitle = False
    
   Dim strValue
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  Writelog("SetDocTitle Parameter = ["& Str & "]")
	
	gFileNetP8.m_oP8Server.SetDocTitle Str
	FNP8_SetDocTitle = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetMimeType(bInter, bDebug, StrParam) 
	FNP8_SetMimeType = False
	  
  strValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if    
  
	gFileNetP8.m_oP8Server.SetMimeType Str
	FNP8_SetMimeType = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetFileMimeType(bInter, bDebug, StrParam) 
    
	FNP8_SetFileMimeType = True
  Dim aStrParam
  Dim fileExt, mimeType
  
  aStrParam = Split(LCase(StrParam), ",", 2)
  If UBound(aStrParam) < 1 Then WriteLog "Invalid parameter" : Exit Function
  
  fileExt = Trim(aStrParam(0))
  mimeType = Trim(aStrParam(1))
  If Left(fileExt, 1) <> "." Then fileExt = "." & fileExt
  If fileExt = "." OR mimeType = "" Then WriteLog "Invalid parameter" : Exit Function
  
  If customMimeTypes.Exists(fileExt) Then
    customMimeTypes.Item(fileExt) = mimeType
  Else
    Call customMimeTypes.Add(fileExt, mimeType)
  End If
  WriteLog "Extension " & fileExt & " MIME type: " & mimeType
  

End Function

Function FNP8_SetProperty(bInter, bDebug, StrParam) 
	FNP8_SetProperty = False
	'StrParam is a CSV Value:
	' (0) is the Property ID
	' (1) is the Property Value
	' (2) is the optional Property Type, if not provided considered "String"

	On Error Resume Next
	Dim aStrParam, strId, strValue, strType
  Dim bRemoveQuotes
  Set regEx = CreateObject("vbscript.regexp")
  regEx.IgnoreCase = True
  regEx.Global = True
  bRemoveQuotes = False
  
	
  strPattern =  "(\'([^]]+)\')"
  regEx.Pattern = strPattern 
  Set Matches = regEx.Execute(strParam)  
  WriteLog("Count = " & Matches.Count)	
  
  if Matches.Count > 0 then 
    bRemoveQuotes = True
    Set Match = Matches(0) 'some params surrounded by quotes    
    aStrParam = Split(StrParam, ",", 2, 1) 
    strId = Trim(aStrParam(0))
	  strValue = Trim(Match.value)
    strValue = Replace(strValue,"'","")
    WriteLog("Property Value = " & strValue)	
	  strType = ""    
    LastIndex = InStrRev(strParam,",")
	  Size = Len(strParam)-LastIndex
	  strType=Right(strParam,Size)	   ' we need to set Mime type for uploadig Image type
  else	
	  aStrParam = Split(StrParam, ",", 3, 1) 
	  strId = Trim(aStrParam(0))
	  strValue = Trim(aStrParam(1))
	  strType = ""
	  If UBound(aStrParam) = 2 Then strType = Trim(aStrParam(2))
  End If
	
	If(strId = "" Or strValue = "") Then
		bAbort = True
		nTaskStatus = RetAbort 	
		WriteLog("Error in FNP8_SetProperty action: Specified parameter is invalid.")
		Exit Function
	End If
    
  str = MetaWord(strId)    
  If len(Trim(str))=0 Then 
    strId = gFileNetP8.GetSpecialVariable(strId, CurrentObj)
  Else
    strId=str
  End if
  
  WriteLog("FNP8_SetProperty property id: " & strId)
  
   str = MetaWord(strValue)    
  If len(Trim(str))=0 Then 
    strValue = gFileNetP8.GetSpecialVariable(StrValue, CurrentObj)
  Else
    strValue=str
  End if
  WriteLog("FNP8_SetProperty property value: " & strValue)
  
  
  str = MetaWord(strType)    
  If len(Trim(str))=0 Then 
    strType = gFileNetP8.GetSpecialVariable(strType, CurrentObj)
  Else
    strType=str
  End if
  WriteLog("FNP8_SetProperty property type: " & strType)
  
  Set regEx = Nothing
    
	If (strValue = "" And strType <> "") Then 'ignore empty value for non-string property
		FNP8_SetProperty = True
		WriteLog("Ignoring emty value for non-string property...")
		Exit Function
	End If
	gFileNetP8.m_oP8Server.AddPropertyType strId, strValue, strType
	If Err.Number = 80131501 Then 'Abort the Task, Multiple values assigned to the single value property 
		WriteLog("Error!!! Multiple values assigned to the single value property")  
	End If
	FNP8_SetProperty = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetPropertyEx(bInter, bDebug, StrParam) 
	FNP8_SetPropertyEx = False
	'StrParam is a CSV Value:
	' (0) is the Property ID
	' (1) is the Property Value
	' (2) is the optional Property Type, if not provided considered "String"

	On Error Resume Next
	Dim aStrParam, strId, strValue, strType
	
	aStrParam = Split(StrParam, ",", 3, 1) 
	
	strId = Trim(aStrParam(0))
	strValue = Trim(aStrParam(1))
	strType = ""
	If UBound(aStrParam) = 2 Then strType = Trim(aStrParam(2))

	If(strId = "" Or strValue = "") Then
		bAbort = True
		nTaskStatus = RetAbort 	
		WriteLog("Error in FNP8_SetPropertyEx action: Specified parameter is invalid.")
		Exit Function
	End If
  
   str = MetaWord(strId)    
  If len(Trim(str))=0 Then 
    strId = gFileNetP8.GetSpecialVariable(strId, CurrentObj)
  Else
    strId=str
  End if
  WriteLog("FNP8_SetPropertyEx property id: " & strId)
  
   str = MetaWord(strValue)    
  If len(Trim(str))=0 Then 
    strValue = gFileNetP8.GetSpecialVariable(StrValue, CurrentObj)
  Else
    strValue=str
  End if
   WriteLog("FNP8_SetPropertyEx property value: " & strValue)
  
  
  str = MetaWord(strType)    
  If len(Trim(str))=0 Then 
    strType = gFileNetP8.GetSpecialVariable(strType, CurrentObj)
  Else
    strType=str
  End if
  WriteLog("FNP8_SetPropertyEx property type: " & strType)
  
	If (strValue = "" And strType <> "") Then 'ignore empty value for non-string property
		FNP8_SetPropertyEx = True
		WriteLog("Ignoring emty value for non-string property...")
		Exit Function
	End If
	gFileNetP8.m_oP8Server.AddPropertyTypeEx strId, strValue, strType	
	FNP8_SetPropertyEx = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetMultiValueProperty(bInter, bDebug, StrParam) 
	FNP8_SetMultiValueProperty = False
	'StrParam is a CSV Value:
	' (0) is the Property ID
	' (1) is the Property Value
	' (2) is the optional Property Type, if not provided considered "String"

	On Error Resume Next
	Dim aStrParam, strId, strValue, strType
	Dim strP8DelimiterVar
	Dim strP8Delimiter
  Dim strPattern
  Dim bRemoveQuotes
  Set regEx = CreateObject("vbscript.regexp")
  regEx.IgnoreCase = True
  regEx.Global = True
  bRemoveQuotes = False
	strP8DelimiterVar = "@APPVAR(values/gen/p8delimiter)"
	strP8Delimter = ""
	
	WriteLog("AddMultiValueProperty Delimeter " & strP8DelimiterVar)
	  
  strPattern =  "(\'([^]]+)\')"
  regEx.Pattern = strPattern 
  Set Matches = regEx.Execute(strParam)  
  WriteLog("Count = " & Matches.Count)	
  if Matches.Count > 0 then 
    bRemoveQuotes = True
    Set Match = Matches(0) 'some params surrounded by quotes    
    aStrParam = Split(StrParam, ",", 2, 1) 
    strId = Trim(aStrParam(0))
	  strValue = Trim(Match.value)
    WriteLog("strValue = " & Matches.value)	
	  strType = ""    
    LastIndex = InStrRev(strParam,",")
	  Size = Len(strParam)-LastIndex
	  strType=Right(strParam,Size)	   ' we need to set Mime type for uploadig Image type
  else	  
    aStrParam = Split(StrParam, ",", 3, 1) 
    strId = Trim(aStrParam(0))
	  strValue = Trim(aStrParam(1))
	  strType = ""
	  If UBound(aStrParam) = 2 Then strType = Trim(aStrParam(2))
  End If
	
  
  If(strId = "" Or strValue = "") Then
		bAbort = True
		nTaskStatus = RetAbort 	
		WriteLog("Error in FNP8_SetMultiValueProperty action: Specified parameter is invalid.")
		Exit Function
	End If
	  
  str = MetaWord(StrValue)
	If len(Trim(str))=0 Then 
		strValue = gFileNetP8.GetSpecialVariable(StrValue, CurrentObj)
	Else
		strValue=str
	End if
  
  WriteLog("FNP8_SetMultiValueProperty property value: " & strValue)
  
  
  str = MetaWord(strId)
	If len(Trim(str))=0 Then 
		strId = gFileNetP8.GetSpecialVariable(strId, CurrentObj)
	Else
		strId=str
	End if
  
   WriteLog("FNP8_SetMultiValueProperty property ID: " & strId)
   
  str = MetaWord(strType)
	If len(Trim(str))=0 Then 
		strType = gFileNetP8.GetSpecialVariable(strType, CurrentObj)
	Else
		strType=str
	End if
  
  WriteLog("FNP8_SetMultiValueProperty property Type: " & strType)
  
  
	If (strValue = "" And strType <> "") Then 'ignore empty value for non-string property
		FNP8_SetProperty = True
		WriteLog("Ignoring empty value for non-string property...")
		Exit Function
	End If
		
    
	str = MetaWord(strP8DelimiterVar)  
	If len(Trim(str))=0 Then 		
		strP8Delimiter = gFileNetP8.GetSpecialVariable(strP8DelimiterVar, CurrentObj)
	Else		
		strP8Delimiter = str
	End if
	
	If len(Trim(strP8Delimiter))=0 Then 		
    if Matches.Count > 0 then       
        Writelog(" @APPVAR values/gen/p8delimiter not found or is empty, using the default '|' delimiter") 		
        strP8Delimiter = "|"     
    Else
        Writelog(" @APPVAR values/gen/p8delimiter not found or is empty, using the default comma delimiter") 
        strP8Delimiter = ","
    End if 
	End if
   
	Writelog("using the delimiter = '" & strP8Delimiter & "'") 
	
	If instr(strValue,strP8Delimiter) > 0 then 
		strPropValues = Split(strValue,strP8Delimiter)
			
    Dim counter
    Dim strNewValue
    for counter = 0 to UBound(strPropValues)
      if Matches.Count > 0 then       
        strSinglePropValue = Replace(strPropValues(counter),"'","")
      Else
        strSinglePropValue = strPropValues(counter)       
      End if      
       WriteLog("AddMultiValueProperty Property Value = " & strSinglePropValue)
       gFileNetP8.m_oP8Server.AddMultiValueProperty strId, strSinglePropValue, strType
    next
	else
	gFileNetP8.m_oP8Server.AddMultiValueProperty strId, strValue, strType
  end if  
	
  Set regEx = Nothing
    
	If Err.Number = 80131501 Then 'Abort the Task, Multiple values assigned to the single value property 
		WriteLog("Error!!! Multiple values assigned to the single value property")
	End If
	FNP8_SetMultiValueProperty = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetTimeout(bInter, bDebug, StrParam) 
	FNP8_SetTimeout = False
	Dim timeout 
      
  str = MetaWord(StrParam)  
	If len(Trim(str))=0 Then 		
		StrParam = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
	Else		
		StrParam = str
	End if
  
  WriteLog("FNP8_SetTimeout value: " & StrParam)
  
	timeout = CLng(StrParam)
	Writelog("Timeout set to:"&timeout)
	gFileNetP8.m_oP8Server.SetTimeout timeout
	FNP8_SetTimeout = gFileNetP8.ErrorHandler()

End Function

Function FNP8_Upload(bInter, bDebug) 
	FNP8_Upload = False
  gFileNetP8.StartNewDoc()

	If (CurrentObj.ObjectType > DCO_PAGE) Then 
		bAbort = True
		nTaskStatus = RetAbort 	                                             
		Writelog("Error: This action must be placed at the Batch, Document, Or Page Level.")
		Exit Function
	End If
	On Error Resume Next
  
  If (gFileNetP8.m_CreateMultiPageDoc = True) Then
  
    WriteLog("FNP8_Upload Creating Multi-Page P8 Document")
    gFileNetP8.m_CreateMultiPageDoc = True
    gFileNetP8.m_oUploaded.CreateDCODoc
    gFileNetP8.m_oP8Server.CreateDoc  ' initialize list of files in the doc 
   
   Dim sMergeFile    
    sMergeFile = CurrentObj.Variable("MergedTiffFileName")
    WriteLog("FNP8_Upload MergedTiffFileName variable returned =  " & sMergeFile)         
    If len(Trim(sMergeFile))=0 Then
      WriteLog("FNP8_Upload MergedTiffFileName NOT found ")    
      WriteLog("FNP8_Upload object type = " & CurrentObj.ObjectType)
      WriteLog("FNP8_Upload object child count = " & CurrentObj.NumofChildren)
      For i = 0 To CurrentObj.NumofChildren-1
			    Set tmpObj = CurrentObj.GetChild(i)
			    WriteLog("FNP8_Upload  recurse to " & tmpObj.ID)
			    If (tmpObj.ObjectType = DCO_DOCUMENT) Then 
              sMergeFile = tmpObj.Variable("MergedTiffFileName")  
              WriteLog("FNP8_Upload tmpObj MergedTiffFileName variable returned =  " & sMergeFile)  
               If len(Trim(sMergeFile)) > 0 Then
                  WriteLog("FNP8_Upload MergedTiffFileName found, break ")  
                  gFileNetP8.m_oP8Server.AddMergedFile(sMergeFile)
                  Exit For
               End If   
          End If
		  Next
    Else
      WriteLog("FNP8_Upload MergedTiffFileName found ")   
      WriteLog("FNP8_Upload will upload the TiffMergedFile =  " & sMergeFile)         
      gFileNetP8.m_oP8Server.AddMergedFile(sMergeFile)
    End If       
    
    gFileNetP8.CreateDocUsingDCO CurrentObj ' uploading files for this doc is done recursively here
     
      WriteLog("FNP8_Upload Upload multi-page document") 
    strId = gFileNetP8.m_oP8Server.UploadDoc 
      WriteLog("FNP8_Upload Upload multi-page complete, id = "& strID) 
    
    gFileNetP8.m_oUploaded.UpdateDCODoc CurrentObj,strID    
    
    If Err.Number <> 0 Then  'We are going to perform retry if can		
		Writelog("FNP8_Upload multi-page upload failed.")
		Dim Str			
		Str= "ERROR!!! N" + CStr(Err.Number) + vbCrLf _
			+ "Error description = " + Err.Description + vbCrLf _
			+ "Error Source = " + Err.Source

		WriteLog(Str)
    ClearError() 'Needed to clear the 'invalid OIID' error
		If Err.Number <> 0 Then
			Do Until I=CInt(m_Retry)
				Err.Clear
	      Writelog("Retrying upload. Attempt # "&I+1&" of " & m_Retry & ".")
				strId = gFileNetP8.m_oP8Server.UploadDoc
				If Err.Number <> 0 Then  
					Writelog("Upload failed.")				
					Str= "ERROR!!! N" + CStr(Err.Number) + vbCrLf _
						+ "Error description = " + Err.Description + vbCrLf _
						+ "Error Source = " + Err.Source
			
					WriteLog(Str)			
					If (m_Retry>I+1) Then 'Clear error only when another attempt will follow								
						Err.Clear
					Else
						Exit Do
					End If
				Else 'Upload succedded and if we do have strID lets exit.
					If (strId <> "") Then	
						Exit Do
					Else
						Writelog("Upload failed: the results do not contain a document ID...")				
					End If				
				End If				
		
				I=I+1
			Loop 
		End If
	End If

	If Err.number<>0 Then			
		ErrorHandler()		
    Writelog("FNP8_upload error, Err.Number <> 0, call the ErrorHandler()") 
    FNP8_Upload = gFileNetP8.ErrorHandler()
		Exit Function
	End If

	If (strId = "") Then

		Err.Raise 1,"FileNetP8.rrx","Upload failed: the results do not contain a document ID..."
		Writelog("FNP8_upload error, empty ID, call the ErrorHandler()") 
    FNP8_Upload = gFileNetP8.ErrorHandler()
		Exit Function

	Else   ' document upload succeeded
		
		strfile = obj.Variable("FILEUPLOADED")
		If (1>Len(strFile)) Then
			obj.Variable("FILEUPLOADED") = sFile
			obj.Variable("Doc_ID") = strId		
		Else
			strFile = obj.Variable("FILEUPLOADED")
			strFile = strFile & "|" & sFile
			id = obj.Variable("Doc_ID")
			id = id & "|" & strId
			obj.Variable("FILEUPLOADED") = strFile
			obj.Variable("Doc_ID")= id
		End If
	End If
	gFileNetP8.m_oUploaded.AddUploaded obj
	WriteLog("Successfully uploaded multi-page document and ID is: " & strId)
    
  Else ' SINGLE PAGE DOCUMENT
    WriteLog("FNP8_Upload - Single Page Document Mode")
    gFileNetP8.m_CreateMultiPageDoc = False	
    gFileNetP8.UploadDCO CurrentObj
    FNP8_Upload = gFileNetP8.ErrorHandler()
  End if
 	
  Writelog("FNP8_Upload - call ClearProperties")
	gFileNetP8.m_oP8Server.ClearProperties
   Writelog("FNP8_Upload - call ClearProperties done")
  FNP8_Upload = True
	

End Function

Function FNP8_UploadDir(bInter, bDebug, StrParam) 
	FNP8_UploadDir = False
	If (CurrentObj.ObjectType > DCO_DOCUMENT) Then 
		bAbort = True
		nTaskStatus = RetAbort
		Writelog("Error: This action must be placed at the Batch, or Document Level.")
		Exit Function
	End If
	bDelete = False

	'StrParam is a CSV Value:
	' (0) is the Directory to upload
	' (1) is the boolean "delete file after upload"

	Dim aStrParam, strDir, strDelete    
  Dim Lie, nLie 
	aStrParam = Split(StrParam, ",", 2, 1) 
	strDir = Trim(aStrParam(0))
	strDelete = Ucase(Trim(aStrParam(1)))
    
  str = MetaWord(strDelete)  
	If len(Trim(str))=0 Then 		
		strDelete = gFileNetP8.GetSpecialVariable(strDelete, CurrentObj)
	Else		
		strDelete = str
	End if
  
  WriteLog("FNP8_UploadDir Delete? : " & strDelete)
    
  str = MetaWord(strDir)  
	If len(Trim(str))=0 Then 		
		strDir = gFileNetP8.GetSpecialVariable(strDir, CurrentObj)
	Else		
		strDir = str
	End if
  
  WriteLog("FNP8_UploadDir Dir: " & strDir)
 
	If(strDelete = "TRUE" Or strDelete = "1") Then bDelete = True

	Dim FSO, Folder, oFile, FC
	Set FSO = CreateObject("Scripting.FileSystemObject")
  
  If Not FSO.FolderExists(strDir) Then
    WriteLog("FNP8_UploadDir Error, the directory: " & strDir & " is not available.")
    FNP8_UploadDir = False
    Exit Function
  End If
  
	

	Set Folder = FSO.GetFolder(strDir) 
	Set FC = Folder.Files 
 
  If (gFileNetP8.m_CreateMultiPageDoc = True) Then
     WriteLog("FNP8_UploadDir Creating Multi-Page P8 Document")
     gFileNetP8.m_oP8Server.CreateDoc
     WriteLog("FNP8_UploadDir Done Creating Multi-Page P8 Document")
          
      WriteLog("FNP8_UploadDir CreateDCODoc")
      gFileNetP8.m_oUploaded.CreateDCODoc      
           
     For Each oFile in FC
      strFile = strDir & "\" & oFile.name

		  On Error Resume Next
		  WriteLog("Adding File = " & strFile)
      gFileNetP8.m_oP8Server.AddFile(strFile)
        ' NB: Redactions not supported for UploadDir
        nLie = ubound(g_aPageList)
        WriteLog("CreateDocUsingDCO ubound g_aPageList nLie = " & nLie)
	      Redim Preserve g_aPageList(nLie + 1)
        g_aPageList(nLie) = strFile       
        WriteLog("FNP8_UploadDir Done adding file to Multi-Page P8 Document")               
      WriteLog("FNP8_UploadDir - move to the next file")
      
       WriteLog("FNP8_UploadDir - move to the next file (multipage doc)")
       gFileNetP8.m_oUploaded.AddUploadedFile strFile        
     Next
       
    
    strId = gFileNetP8.m_oP8Server.UploadDoc 
    WriteLog("FNP8_Upload Upload multi-page complete, id = "& strID) 
    gFileNetP8.m_oUploaded.UpdateDCODoc CurrentObj,strID
            
	  Set FCEx = Folder.Files     
    For Each oFile in FCEx	
		  strFile = strDir & "\" & oFile.name
      WriteLog("FNP8_UploadDir - Processing File After Upload = " & strFile)
      If bDelete Then	'delete after upload
        WriteLog("FNP8_UploadDir - Delete = " & strFile)
			  gFileNetP8.m_oP8Server.DeleteFile strFile         
		  Else						'move it to strDir + \Uploaded
      If Not bDelete And Not FSO.FolderExists(strDir & "\Uploaded") Then FSO.CreateFolder(strDir & "\Uploaded")
        WriteLog("FNP8_UploadDir - Move = " & strDir & "\Uploaded\" & oFile.name)
			  oFile.Move(strDir & "\Uploaded\" & oFile.name)
		  End If
    Next
      
    If (strId = "") Then
			WriteLog("The results do not contain a document ID...")
      FNP8_UploadDir = False
			Exit Function
		Else     
			WriteLog("Successfully uploaded and ID is: " & strId)
		End If
          		
    gFileNetP8.m_oP8Server.ClearProperties
	  FNP8_UploadDir = True
    
  Else   
   WriteLog("FNP8_UploadDir Creating Single Page P8 Document")
	For Each oFile in FC
	
		strFile = strDir & "\" & oFile.name

		On Error Resume Next
		WriteLog("Uploading " & strFile)

		Call gFileNetP8.CheckFileType(oFile.Name)
		strId = gFileNetP8.m_oP8Server.Upload(strFile)
		FNP8_UploadDir = gFileNetP8.ErrorHandler()
   
		If (FNP8_UploadDir = False) Then 
			gFileNetP8.m_oP8Server.ClearProperties
			Exit Function
		End If

		If (strId = "") Then
			WriteLog("The results do not contain a document ID...")
			Exit Function
		Else      			         
      gFileNetP8.m_oUploaded.AddNewDoc strFile, strId      
		End If

		If bDelete Then	'delete after upload
			WriteLog("FNP8_UploadDir (single page mode) - Delete = " & strFile)
			gFileNetP8.m_oP8Server.DeleteFile strFile   
		Else						'move it to strDir + \Uploaded
			oFile.Move(strDir & "\Uploaded\" & oFile.name)
		End If
	Next
  gFileNetP8.m_oP8Server.ClearProperties
	FNP8_UploadDir = True
  End If


	

End Function

Function FNP8_SetFileType(bInter, bDebug, StrParam) 
  gFileNetP8.m_FileType = "defaultqwerty.tif" 
  
   str = MetaWord(StrParam)  
	If len(Trim(str))=0 Then 		
		StrParam = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
	Else		
		StrParam = str
	End if
  
  WriteLog("FNP8_SetFileType Mime: " & StrParam)
 
  If Len(StrParam) =3  Then 'Extension specified in format "xxx" 
     gFileNetP8.m_FileType = "."&StrParam
  End If

  If Len(StrParam) >3 Then  'Extension specified in some other format, " '.tif' " or " *.tif " will try to find "." and parse the string
    If InStr(StrParam,".") <> 0 Then
	If Len(Mid(StrParam,InStr(StrParam,"."),5))=5 Then  'there are 4 characters after "."
	      gFileNetP8.m_FileType = Mid(StrParam,InStr(StrParam,"."),5)		
	Else
	      If Len(Mid(StrParam,InStr(StrParam,"."),4))=4 Then  'there are 3 characters after "."
		      gFileNetP8.m_FileType = Mid(StrParam,InStr(StrParam,"."),4)
	      End If
        End If
    Else 'Extension specified in xxxx format
	If Len(StrParam) = 4 Then
		gFileNetP8.m_FileType = "."&StrParam
	End If
    End If
  End If


  If gFileNetP8.m_FileType="defaultqwerty.tif" Then
     gFileNetP8.m_FileType=".tif"
     Writelog("File type specified in incorrect format. Use 'tif', '*.tif' or 'example.tif'. Set to default value '.tif'") 
  Else
     Writelog("Set upload file type to '" & gFileNetP8.m_FileType & "'") 
     End If

  gFileNetP8.m_oP8Server.SetMimeType (gFileNetP8.GetMimeType(gFileNetP8.m_FileType))			
  Writelog("MIME Type set to '" & gFileNetP8.GetMimeType(gFileNetP8.m_FileType) & "'")             
  FNP8_SetFileType = gFileNetP8.ErrorHandler()

End Function

Function FNP8_SetUploadMode(bInter, bDebug, StrParam) 

  Dim sSmartParam

  
  str = MetaWord(StrParam)  
	If len(Trim(str))=0 Then 		
		StrParam = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
	Else		
		StrParam = str
	End if
  
  WriteLog("FNP8_SetUploadMode = " & StrParam)

  gFileNetP8.m_DCOVariable = StrParam
  Writelog("Set upload mode to upload file specified in variable '" & gFileNetP8.m_DCOVariable & "'")


End Function

Function FNP8_MultiPageDocs(bInter, bDebug, StrParam) 

 
  
  str = MetaWord(StrParam)  
	If len(Trim(str))=0 Then 		
		StrParam = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
	Else		
		StrParam = str
	End if
  
  
  WriteLog("FNP8_SetMultiPageDocs = " & StrParam)
  If(StrParam = "True" Or StrParam = "1" Or StrParam = "TRUE") Then 
    gFileNetP8.m_CreateMultiPageDoc = True
     WriteLog("FNP8_MultiPageDocs = Enabled")
  Else
     gFileNetP8.m_CreateMultiPageDoc = False
     WriteLog("FNP8_MultiPageDocs = Disabled")
  End If

  Writelog("FNP8_MultiPageDocs has been set to '" & StrParam & "'")


End Function

Function FNP8_SetRetry(bInter, bDebug, StrParam) 

  Dim sSmartParam

  On Error Resume Next

  str = MetaWord(StrParam)  
	If len(Trim(str))=0 Then 		
		StrParam = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
	Else		
		StrParam = str
	End if
  
  
  WriteLog("FNP8_SetRetry = " & StrParam)
  
  gFileNetP8.m_Retry = CInt(StrParam)
  Writelog("Set amount of upload retries to  '" & gFileNetP8.m_Retry & "'") 
  FNP8_SetRetry = gFileNetP8.ErrorHandler()


End Function

Function FNP8_SetKeyProperty(bInter, bDebug, StrParam) 

 FNP8_SetKeyProperty = False
	'StrParam is a CSV Value:
	' (0) is the Property ID
	' (1) is the Property Value
   
	Writelog("Entry SetKeyProperty parsing parameters StrParam: " & StrParam)
 
	On Error Resume Next
	Dim aStrParam, strId, strValue
	
	aStrParam = Split(StrParam, ",", 2, 1) 
	
	strId = Trim(aStrParam(0))
	strValue = Trim(aStrParam(1))
     
	If(strId = "" Or strValue = "") Then
		bAbort = True
		nTaskStatus = RetAbort 	
		WriteLog("Error in FNP8_SetKeyProperty action: Specified parameters are missing or invalid.")
		Exit Function
	End If
  
  Writelog("SetKeyProperty Processing Smart Params strValue = " & strValue)
    
  str = MetaWord(strValue)  
	If len(Trim(str))=0 Then 		
		strValue = gFileNetP8.GetSpecialVariable(strValue, CurrentObj)
	Else		
		strValue = str
	End if
  
  Writelog("SetKeyProperty Smart Params returned strValue = " & strValue)
  
	If (strValue = "" And strType <> "") Then 'ignore empty value for non-string property
		FNP8_SetProperty = True
		WriteLog("Ignoring emty value for non-string property...")
		Exit Function
	End If
   
   Writelog("SetKeyProperty Processing Smart Params strId = " & strId)
  
   str = MetaWord(strId)  
	If len(Trim(str))=0 Then 		
		strId = gFileNetP8.GetSpecialVariable(strId, CurrentObj)
	Else		
		strId = str
	End if
  
  Writelog("SetKeyProperty Smart Params returned strId = " & strId)
  
  Writelog("Starting SetKeyProperty strId: " & strId)
  Writelog("Starting SetKeyProperty strValue: " & strValue)
	gFileNetP8.m_oP8Server.SetKeyProperty strId, strValue
	
	FNP8_SetKeyProperty = gFileNetP8.ErrorHandler()


End Function

Function FNP8_UpdateProperties(bInter, bDebug) 
  
 	FNP8_UpdateProperties = False
  
  Dim ret

  Writelog("Entry FNP8_UpdateProperties")
  
	On Error Resume Next	
	gFileNetP8.m_oP8Server.UpdateProperties
  gFileNetP8.m_oP8Server.ClearProperties 
   
  ret = gFileNetP8.ErrorHandler()  
   
  Writelog("FNP8_UpdateProperties returned = " & ret)
   
  Writelog("FNP8_UpdateProperties Complete")
  
  FNP8_UpdateProperties = ret
  

End Function

Function FNP8_SetSearchClass(bInter, bDebug, StrParam) 
  FNP8_SetSearchClass = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchClass param = " & Str)
  If len(Str)=0 Then
     WriteLog("Error: Empty value not permitted for FNP8_SetSearchClass action")
     FNP8_SetSearchClass=False
     Exit Function
  End If
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchClass Str
  
  FNP8_SetSearchClass = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchDownloadDir(bInter, bDebug, StrParam) 
  FNP8_SetSearchDownloadDir = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchDownloadDir param = " & Str)
  
  If len(Str)=0 Then
     WriteLog("Error: Empty value not permitted for FNP8_SetSearchDownloadDir action")
     FNP8_SetSearchDownloadDir=False
     Exit Function
  End If
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchDownloadDir Str
  
  FNP8_SetSearchDownloadDir = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchWhereClause(bInter, bDebug, StrParam) 
  FNP8_SetSearchWhereClause = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchWhereClause param = " & Str)
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchWhereClause Str
  
  FNP8_SetSearchWhereClause = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchAndDownloadStatusProperty(bInter, bDebug, StrParam) 
  FNP8_SetSearchAndDownloadStatusProperty = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchAndDownloadStatusProperty param = " & Str)
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchAndDownloadStatusAttribute Str
  
  FNP8_SetSearchAndDownloadStatusProperty = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchMaxItems(bInter, bDebug, StrParam) 
  FNP8_SetSearchMaxItems = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchMaxItems param = " & Str)
  
  Dim MaxItemsInt
  
  On Error Resume Next
	MaxItemsInt = CInt(Str)

  FNP8_SetSearchMaxItems = gFileNetP8.ErrorHandlerWithoutAbort()
  
  if FNP8_SetSearchMaxItems=False Then
    WriteLog("Error: Invalid value for the max items: " & Str & ". Please specify a numeric value.")
    Exit Function
  End if
  
  Writelog("Max items set to:"& MaxItemsInt)
    
  gFileNetP8.m_oP8Server.SetSearchMaxItems MaxItemsInt
  
  FNP8_SetSearchMaxItems = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchFolderRestriction(bInter, bDebug, StrParam) 
  FNP8_SetSearchFolderRestriction = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchFolderRestriction param = " & Str)
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchFolderRestriction Str
  
  FNP8_SetSearchFolderRestriction = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchOrderBy(bInter, bDebug, StrParam) 
  FNP8_SetSearchOrderBy = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchOrderBy param = " & Str)
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchOrderBy Str
  
  FNP8_SetSearchOrderBy = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchIncludeDocsWithoutContent(bInter, bDebug, StrParam) 
  FNP8_SetSearchIncludeDocsWithoutContent = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchIncludeDocsWithoutContent param = " & Str)
  
  Dim boolVal
  If Str="true" OR Str="TRUE" OR  Str="True" Then
     boolVal = True
  ElseIf Str="false" OR Str="FALSE" OR Str="False" Then
     boolVal = False
  End If
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchIncludeDocsWithoutContent boolVal
  
  FNP8_SetSearchIncludeDocsWithoutContent = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchIncludeSubClasses(bInter, bDebug, StrParam) 
  FNP8_SetSearchIncludeSubClasses = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchIncludeSubClasses param = " & Str)
  
  Dim boolVal
  If Str="true" OR Str="TRUE" OR  Str="True" Then
     boolVal = True
  ElseIf Str="false" OR Str="FALSE" OR Str="False" Then
     boolVal = False
  End If

  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchIncludeSubClasses boolVal
  
  FNP8_SetSearchIncludeSubClasses = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SetSearchCurrentVersionOnly(bInter, bDebug, StrParam) 
  FNP8_SetSearchCurrentVersionOnly = ""
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetSearchCurrentVersionOnly param = " & Str)
  
  Dim boolVal
  If Str="true" OR Str="TRUE" OR  Str="True" Then
     boolVal = True
  ElseIf Str="false" OR Str="FALSE" OR Str="False" Then
     boolVal = False
  End If
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetSearchCurrentVersionOnly boolVal
  
  FNP8_SetSearchCurrentVersionOnly = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_SearchAndDownload(bInter, bDebug) 
  
 	FNP8_SearchAndDownload = False
  
  Dim ret
  
	On Error Resume Next	
	gFileNetP8.m_oP8Server.SearchAndDownload
  
  ret = gFileNetP8.ErrorHandlerWithoutAbort()  
   
  Writelog("FNP8_SearchAndDownload returned = " & ret)
  
  FNP8_SearchAndDownload = ret
  

End Function

Function FNP8_AddRedactionsToP8Document(bInter, bDebug) 
 
  Dim sImage
  
 	FNP8_AddRedactionsToP8Document = False

  gFileNetP8.StartNewDoc()

	If (CurrentObj.ObjectType <> DCO_PAGE) Then                                             
		Writelog("Error: This action must be placed on the Page Level.")
		Exit Function
	End If
  
	sImage = CurrentObj.ImageName
  
	m_pageCount = m_pageCount + 1
	   
  if gFileNetP8.IsRedactFileType(sImage) Then
      ' NSK: For each uploaded file (page), if it is a file type that can contain redactions...
      ' NSK: Send redactions on this image to server to create annotations- TBD PAGE NUMBER
		  gFileNetP8.GetAnnotation CurrentObj,m_pageCount,sImage
      
      Dim myDocId  
      myDocId = CurrentObj.Variable("PageName")
      WriteLog("FNP8_AddRedactions - Adding redactions for document with ID: " & myDocId)
      
      On Error Resume Next
	    gFileNetP8.m_oP8Server.UpdateAnnotations myDocId
  
      WriteLog("FNP8_AddRedactions - Added redactions for document with ID: " & myDocId)
      
	    gFileNetP8.m_oP8Server.ClearProperties
      
	End If
            
  FNP8_AddRedactionsToP8Document = gFileNetP8.ErrorHandlerWithoutAbort()
   	
  

End Function

Function FNP8_SetOverrideCheckoutOnUpdateContent(bInter, bDebug, StrParam) 
  ' RTC 176444: Update content of document
  FNP8_SetOverrideCheckoutOnUpdateContent = False
  
  StrValue = MetaWord(StrParam)
  If len(Trim(strValue))=0 Then     
	  Str = gFileNetP8.GetSpecialVariable(StrParam, CurrentObj)
  Else
	  Str=strValue
  End if  
  
  WriteLog("FNP8_SetOverrideCheckoutOnUpdateContent param = " & Str)
  
  Dim boolVal
  If Str="true" OR Str="TRUE" OR  Str="True" Then
     boolVal = True
  ElseIf Str="false" OR Str="FALSE" OR Str="False" Then
     boolVal = False
  End If
  
  If IsEmpty(boolVal) Then
    WriteLog("Error: FNP8_SetOverrideCheckoutOnUpdateContent - parameter must be True or False. Unrecognized parameter " & Str)
    Exit Function
  End If
  
  On Error Resume Next
  gFileNetP8.m_oP8Server.SetOverrideCheckoutOnUpdateContent boolVal
  
  FNP8_SetOverrideCheckoutOnUpdateContent = gFileNetP8.ErrorHandlerWithoutAbort()
  

End Function

Function FNP8_UpdateContent(bInter, bDebug) 
  ' RTC 176444: Update content of document
	FNP8_UpdateContent = False
  gFileNetP8.StartNewDoc()

	If ( (CurrentObj.ObjectType > DCO_PAGE) OR  (CurrentObj.ObjectType < DCO_DOCUMENT)) Then                                             
		Writelog("Error: This action must be placed on the Page or Document Level.")
		Exit Function
	End If
	On Error Resume Next
  
  ' ---- START: Get PageName (DocID) from the first page in the document ----
  Dim localFilePath
  localFilePath=""
  Dim strId
  strId=""
  Dim origDocID
  
  WriteLog("FNP8_UpdateContent looking for PageName")
    
  If (CurrentObj.ObjectType = DCO_DOCUMENT) Then
    WriteLog("FNP8_UpdateContent - Document level - get PageName from first page of document. Document ID: " & CurrentObj.ID)
	  origDocID = CurrentObj.GetChild(0).Variable("PageName")
  ElseIf (CurrentObj.ObjectType = DCO_BATCH) Then
    WriteLog("FNP8_UpdateContent - Batch level - get PageName from first page of first document. Batch ID: " & CurrentObj.ID)
	  origDocID = CurrentObj.GetChild(0).GetChild(0).Variable("PageName") 
  Else
    ' the only remaining option is we are at page-level (DCO_FIELD was ruled out in earlier IF condition at the top)
    WriteLog("FNP8_UpdateContent - at Page level - Page ID: " & CurrentObj.ID)
    origDocID = CurrentObj.Variable("PageName")
  End If

  WriteLog("FNP8_UpdateContent Got PageName=" & origDocID & ", PageName length = " & Len(origDocID))
  
  If Len(origDocID) = 0 Then
    Writelog("Error: The required page-level variable PageName was not set.  PageName must be set to the object ID of the document to be updated.")
    Err.Raise 1,"FileNetP8.rrx","The required page-level variable PageName was not set.  PageName must be set to the object ID of the document to be updated."
    Exit Function
  End If
  
  ' ---- END: Get PageName from the first page in the document:  ----
     
  Dim sMergeFile
  
  If (gFileNetP8.m_CreateMultiPageDoc = True) Then 
    '  ----- START: Multi-page documents -----
    WriteLog("FNP8_UpdateContent Creating Multi-Page P8 Document")
    gFileNetP8.m_CreateMultiPageDoc = True
    gFileNetP8.m_oUploaded.CreateDCODoc
    gFileNetP8.m_oP8Server.CreateDoc  ' initialize list of files in the doc 
       
    sMergeFile = CurrentObj.Variable("MergedTiffFileName")
    WriteLog("FNP8_UpdateContent MergedTiffFileName variable returned =  " & sMergeFile)         
    If len(Trim(sMergeFile))=0 Then
      ' ----- START: Look for MergedTiffFileName at each level:  -----
      WriteLog("FNP8_UpdateContent MergedTiffFileName NOT found ")    
      WriteLog("FNP8_UpdateContent object type = " & CurrentObj.ObjectType)
      WriteLog("FNP8_UpdateContent object child count = " & CurrentObj.NumofChildren)
      For i = 0 To CurrentObj.NumofChildren-1
			    Set tmpObj = CurrentObj.GetChild(i)
			    WriteLog("FNP8_UpdateContent  recurse to " & tmpObj.ID)
			    If (tmpObj.ObjectType = DCO_DOCUMENT) Then 
              sMergeFile = tmpObj.Variable("MergedTiffFileName")  
              WriteLog("FNP8_UpdateContent tmpObj MergedTiffFileName variable returned =  " & sMergeFile)  
               If len(Trim(sMergeFile)) > 0 Then
                  localFilePath = sMergeFile
                  WriteLog("FNP8_UpdateContent MergedTiffFileName found, break ")  
                  gFileNetP8.m_oP8Server.AddMergedFile(sMergeFile)
                  Exit For
               End If   
          End If
		  Next
      ' ----- END: Look for MergedTiffFileName at each level  -----
    Else      
      WriteLog("FNP8_UpdateContent MergedTiffFileName found:  " & sMergeFile)         
      gFileNetP8.m_oP8Server.AddMergedFile(sMergeFile)
      localFilePath = sMergeFile
    End If       
            
    If Len(localFilePath) = 0 Then
      Writelog("No mergeTiffFile was found, add documents to be uploaded")
      gFileNetP8.UpdateDocUsingDCO CurrentObj ' updating files for this doc is done recursively here
    End If
    
    WriteLog("FNP8_UpdateContent Update multi-page document") 
    strId = gFileNetP8.m_oP8Server.UpdateContent(origDocID)
      
	  If Err.number<>0 Then			
		  ErrorHandlerWithoutAbort()
		  Exit Function
	  End If

	  If (strId = "") Then
      WriteLog("Update failed for document ID: " & origDocID & ". The results do not contain a new document ID.")
		  Err.Raise 1,"FileNetP8.rrx","Update failed: the results do not contain a document ID..."
		  ' NSK TBD should we return false?
		  Exit Function
	  Else   ' document upload succeeded      
      gFileNetP8.UpdateUploadInfoInDCO CurrentObj,localFilePath,strId
	  End If
    
    ' Add upload info based on the DCO
	  gFileNetP8.m_oUploaded.AddUploaded CurrentObj
    
	  WriteLog("FNP8_UpdateContent Successfully updated multi-page document. New ID is: " & strId)
    
    ' ----- Multi-page documents: END ----- 
  
  Else 
    ' ---- START: SINGLE PAGE DOCUMENT ----
    WriteLog("FNP8_UpdateContent - Single Page Document Mode")
    gFileNetP8.m_CreateMultiPageDoc = False	
  
    Dim sImage  
    sImage = CurrentObj.ImageName
      
    WriteLog("FNP8_UpdateContent - updating content: docID=" & origDocID)
    FNP8_UpdateContent = gFileNetP8.UpdateDCO(CurrentObj,origDocID)
    
   ' ---- END: SINGLE PAGE DOCUMENT ----
  End If
    
  FNP8_UpdateContent = gFileNetP8.ErrorHandlerWithoutAbort()
 	                     
  Writelog("FNP8_UpdateContent - call ClearProperties")
	gFileNetP8.m_oP8Server.ClearProperties
  Writelog("FNP8_UpdateContent - call ClearProperties done")
  
  

End Function
